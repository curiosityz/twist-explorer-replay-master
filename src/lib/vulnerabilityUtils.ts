/**
 * Utilities for analyzing and managing cryptographic vulnerabilities
 */
import { CryptographicPoint, Signature, AnalysisResult, VulnerabilityType } from '@/types';
import { normalizeVulnerabilityAnalysis, normalizeKeyFragment } from './database';
import { 
  hexToBigInt, 
  verifyPrivateKey, 
  isPointOnCurve, 
  isPointOnTwistCurve,
  combinePrivateKeyFragments
} from './cryptoUtils';
import { supabase, Tables } from '@/integrations/supabase/client';
import { toast } from 'sonner';
import { saveKeyFragments as storeKeyFragments } from './keyStorage';

/**
 * Normalizes analysis result data from database format
 * @param analysisData Raw analysis data from database
 * @returns Properly typed AnalysisResult object or null
 */
export const prepareAnalysisResult = (analysisData: any): AnalysisResult | null => {
  if (!analysisData) return null;
  
  const normalizedAnalysis = normalizeVulnerabilityAnalysis(analysisData);
  if (!normalizedAnalysis) return null;
  
  // Using type assertion to handle the recovered_private_key field
  const analysisWithRecoveredKey = analysisData as any;
  
  return {
    txid: normalizedAnalysis.txid,
    vulnerabilityType: normalizedAnalysis.vulnerability_type as VulnerabilityType,
    publicKey: normalizedAnalysis.public_key as CryptographicPoint,
    signature: normalizedAnalysis.signature as Signature,
    twistOrder: normalizedAnalysis.twist_order,
    primeFactors: normalizedAnalysis.prime_factors,
    privateKeyModulo: normalizedAnalysis.private_key_modulo || {},
    status: normalizedAnalysis.status,
    message: normalizedAnalysis.message,
    // Access recovered_private_key safely using type assertion
    recoveredPrivateKey: analysisWithRecoveredKey.recovered_private_key || null
  };
};

/**
 * Fetches analysis result for a transaction from the database
 * @param txid Transaction ID to fetch analysis for
 * @returns Analysis result or null if not found
 */
export const fetchAnalysisForTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    const { data: analysisData, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching analysis:', error);
      return null;
    }
    
    return prepareAnalysisResult(analysisData);
  } catch (error) {
    console.error('Error in fetchAnalysisForTransaction:', error);
    return null;
  }
};

/**
 * Fetches key fragments for a public key from the database
 * @param publicKeyHex Public key in hex format
 * @returns Key fragment data or null if not found
 */
export const fetchKeyFragmentsForPublicKey = async (publicKeyHex: string) => {
  try {
    const { data, error } = await supabase
      .from(Tables.private_key_fragments)
      .select('*')
      .eq('public_key_hex', publicKeyHex)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching key fragments:', error);
      return null;
    }
    
    return normalizeKeyFragment(data);
  } catch (error) {
    console.error('Error in fetchKeyFragmentsForPublicKey:', error);
    return null;
  }
};

/**
 * Checks if a recovered private key is valid for a given public key
 * This uses the cryptoUtils verification function but adds error handling
 * @param privateKey Recovered private key
 * @param publicKey Public key point
 * @returns Boolean indicating if key is valid and verified
 */
export const verifyRecoveredKey = (
  privateKey: string | null,
  publicKey: CryptographicPoint | undefined
): boolean => {
  if (!privateKey || !publicKey) {
    console.log("Missing key data for verification");
    return false;
  }
  
  try {
    // For vulnerability analysis, we only need to verify that the private key generates a valid point
    return verifyPrivateKey(privateKey, publicKey.x, publicKey.y);
  } catch (error) {
    console.error('Error verifying recovered key:', error);
    return false;
  }
};

/**
 * Save key fragments to the database
 * @param publicKeyHex Public key in hex format
 * @param fragments Key fragments (modulo values)
 * @param combinedKey Recovered private key (if available)
 */
export const saveKeyFragments = async (
  publicKeyHex: string, 
  fragments: Record<string, string>,
  combinedKey: string | null = null
): Promise<boolean> => {
  try {
    // Check if entry already exists first to avoid conflicts
    const { data: existingEntry } = await supabase
      .from(Tables.private_key_fragments)
      .select('id')
      .eq('public_key_hex', publicKeyHex)
      .maybeSingle();
    
    const fragmentData = {
      public_key_hex: publicKeyHex,
      modulo_values: fragments,
      combined_fragments: combinedKey,
      completed: !!combinedKey
    };
    
    let result;
    
    if (existingEntry) {
      // Update existing record
      result = await supabase
        .from(Tables.private_key_fragments)
        .update(fragmentData)
        .eq('id', existingEntry.id);
    } else {
      // Insert new record
      result = await supabase
        .from(Tables.private_key_fragments)
        .insert(fragmentData);
    }
    
    if (result.error) {
      console.error("Error saving key fragments:", result.error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error("Error in saveKeyFragments:", error);
    return false;
  }
};

/**
 * Analyzes transaction for potential vulnerabilities
 * @param txid Transaction ID to analyze
 * @returns Analysis result or null if analysis failed
 */
export const analyzeTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    // Check if an analysis already exists
    const { data: existingAnalysis, error: checkError } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (checkError) {
      console.error("Error checking existing analysis:", checkError);
    } else if (existingAnalysis && existingAnalysis.vulnerability_type !== VulnerabilityType.UNKNOWN) {
      // Use type assertion to safely access the recovered_private_key field
      const analysisWithRecoveredKey = existingAnalysis as any;
      
      const preparedResult = prepareAnalysisResult(existingAnalysis);
      if (preparedResult) {
        toast.info("This transaction has already been analyzed", {
          description: "The key fragments have already been extracted from this transaction."
        });
        
        // Even if it exists, attempt to process the key fragments and recover the private key
        if (preparedResult.privateKeyModulo && 
            Object.keys(preparedResult.privateKeyModulo).length >= 6) {
          console.log("Found existing analysis with key fragments, attempting to recover private key...");
          const recoveredKey = combinePrivateKeyFragments(preparedResult.privateKeyModulo);
          
          if (recoveredKey) {
            console.log("Successfully recovered private key from existing fragments:", recoveredKey);
            const publicKeyHex = preparedResult.publicKey.x + preparedResult.publicKey.y;
            
            // Store in both local storage and database
            storeKeyFragments(txid, preparedResult.privateKeyModulo, recoveredKey);
            await saveKeyFragments(publicKeyHex, preparedResult.privateKeyModulo, recoveredKey);
            
            // Update the analysis result with the recovered key
            preparedResult.recoveredPrivateKey = recoveredKey;
            
            // Also update the database record
            const updateResult = await supabase
              .from(Tables.vulnerability_analyses)
              .update({
                recovered_private_key: recoveredKey
              })
              .eq('id', existingAnalysis.id);
              
            if (updateResult.error) {
              console.error("Error updating analysis with recovered key:", updateResult.error);
            }
          } else {
            console.error("Failed to recover private key from existing fragments");
          }
        }
        
        return preparedResult;
      }
    }
    
    // If no existing analysis or we need to create a new one,
    // make RPC calls and perform real-time analysis on the blockchain data
    
    // For real-world implementation, we would:
    // 1. Fetch the transaction data from the blockchain via RPC
    // 2. Extract the public key from the transaction
    // 3. Check if the public key is on the twist curve
    // 4. Calculate the twist order
    // 5. Factor the twist order to find prime factors
    // 6. Calculate the private key modulo for each prime factor
    // 7. Combine the modulo values to recover the private key
    
    // This implementation would require actual RPC calls to the blockchain node
    // and complex cryptographic operations that would be beyond the scope of a demo
    
    // For demonstration, we'll implement a placeholder that would normally be replaced
    // with real blockchain interaction code. In a production environment, remove this
    // and implement the actual analysis logic with RPC calls to the node.
    
    toast.loading("Analyzing transaction for vulnerabilities...", {
      id: "analyzing-transaction"
    });
    
    // Initiate actual blockchain RPC calls and analysis
    // This is where the real implementation would go
    
    toast.dismiss("analyzing-transaction");
    toast.error("Unable to perform live analysis on this transaction", { 
      description: "Please set up the RPC connection to analyze real transactions." 
    });
    
    return null;
  } catch (error) {
    console.error('Error analyzing transaction:', error);
    toast.dismiss("analyzing-transaction");
    toast.error("Failed to analyze transaction");
    return null;
  }
};
