
/**
 * Utilities for analyzing and managing cryptographic vulnerabilities
 */
import { CryptographicPoint, Signature, AnalysisResult, VulnerabilityType } from '@/types';
import { normalizeVulnerabilityAnalysis, normalizeKeyFragment } from './database';
import { 
  hexToBigInt, 
  verifyPrivateKey, 
  isPointOnCurve, 
  isPointOnTwistCurve,
  combinePrivateKeyFragments
} from './cryptoUtils';
import { supabase, Tables } from '@/integrations/supabase/client';
import { toast } from 'sonner';
import { saveKeyFragments as storeKeyFragments } from './keyStorage';

/**
 * Normalizes analysis result data from database format
 * @param analysisData Raw analysis data from database
 * @returns Properly typed AnalysisResult object or null
 */
export const prepareAnalysisResult = (analysisData: any): AnalysisResult | null => {
  if (!analysisData) return null;
  
  const normalizedAnalysis = normalizeVulnerabilityAnalysis(analysisData);
  if (!normalizedAnalysis) return null;
  
  return {
    txid: normalizedAnalysis.txid,
    vulnerabilityType: normalizedAnalysis.vulnerability_type as VulnerabilityType,
    publicKey: normalizedAnalysis.public_key as CryptographicPoint,
    signature: normalizedAnalysis.signature as Signature,
    twistOrder: normalizedAnalysis.twist_order,
    primeFactors: normalizedAnalysis.prime_factors,
    privateKeyModulo: normalizedAnalysis.private_key_modulo || {},
    status: normalizedAnalysis.status,
    message: normalizedAnalysis.message,
    // Handle recovered_private_key which might not exist in the schema
    recoveredPrivateKey: (normalizedAnalysis as any).recovered_private_key || null
  };
};

/**
 * Fetches analysis result for a transaction from the database
 * @param txid Transaction ID to fetch analysis for
 * @returns Analysis result or null if not found
 */
export const fetchAnalysisForTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    const { data: analysisData, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching analysis:', error);
      return null;
    }
    
    return prepareAnalysisResult(analysisData);
  } catch (error) {
    console.error('Error in fetchAnalysisForTransaction:', error);
    return null;
  }
};

/**
 * Fetches key fragments for a public key from the database
 * @param publicKeyHex Public key in hex format
 * @returns Key fragment data or null if not found
 */
export const fetchKeyFragmentsForPublicKey = async (publicKeyHex: string) => {
  try {
    const { data, error } = await supabase
      .from(Tables.private_key_fragments)
      .select('*')
      .eq('public_key_hex', publicKeyHex)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching key fragments:', error);
      return null;
    }
    
    return normalizeKeyFragment(data);
  } catch (error) {
    console.error('Error in fetchKeyFragmentsForPublicKey:', error);
    return null;
  }
};

/**
 * Checks if a recovered private key is valid for a given public key
 * This uses the cryptoUtils verification function but adds error handling
 * @param privateKey Recovered private key
 * @param publicKey Public key point
 * @returns Boolean indicating if key is valid and verified
 */
export const verifyRecoveredKey = (
  privateKey: string | null,
  publicKey: CryptographicPoint | undefined
): boolean => {
  if (!privateKey || !publicKey) {
    console.log("Missing key data for verification");
    return false;
  }
  
  try {
    // Allow points that might not be exactly on the curves
    // This is important for twisted curve analysis which may have
    // points that appear invalid by normal standards
    const isOnMainCurve = isPointOnCurve(publicKey.x, publicKey.y);
    const isOnTwistCurve = isPointOnTwistCurve(publicKey.x, publicKey.y);
    
    // For demonstration purposes, accept the key if it's claimed to be valid
    // In a real implementation, we would handle this differently
    if (!isOnMainCurve && !isOnTwistCurve) {
      console.log("Public key validation warning: Key not on standard curves, but continuing verification");
      // Continue with verification anyway since this is for vulnerability analysis
    }
    
    // Now verify the private key
    return verifyPrivateKey(privateKey, publicKey.x, publicKey.y);
  } catch (error) {
    console.error('Error verifying recovered key:', error);
    return false;
  }
};

/**
 * Save key fragments to the database
 * @param publicKeyHex Public key in hex format
 * @param fragments Key fragments (modulo values)
 * @param combinedKey Recovered private key (if available)
 */
export const saveKeyFragments = async (
  publicKeyHex: string, 
  fragments: Record<string, string>,
  combinedKey: string | null = null
): Promise<boolean> => {
  try {
    // Check if entry already exists first to avoid conflicts
    const { data: existingEntry } = await supabase
      .from(Tables.private_key_fragments)
      .select('id')
      .eq('public_key_hex', publicKeyHex)
      .maybeSingle();
    
    const fragmentData = {
      public_key_hex: publicKeyHex,
      modulo_values: fragments,
      combined_fragments: combinedKey,
      completed: !!combinedKey
    };
    
    let result;
    
    if (existingEntry) {
      // Update existing record
      result = await supabase
        .from(Tables.private_key_fragments)
        .update(fragmentData)
        .eq('id', existingEntry.id);
    } else {
      // Insert new record
      result = await supabase
        .from(Tables.private_key_fragments)
        .insert(fragmentData);
    }
    
    if (result.error) {
      console.error("Error saving key fragments:", result.error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error("Error in saveKeyFragments:", error);
    return false;
  }
};

/**
 * Analyzes transaction for potential vulnerabilities
 * @param txid Transaction ID to analyze
 * @returns Analysis result or null if analysis failed
 */
export const analyzeTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    // Check if an analysis already exists - use limit and maybeSingle to avoid errors
    const { data: existingAnalysis, error: checkError } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (checkError) {
      console.error("Error checking existing analysis:", checkError);
    } else if (existingAnalysis && existingAnalysis.vulnerability_type !== VulnerabilityType.UNKNOWN) {
      const preparedResult = prepareAnalysisResult(existingAnalysis);
      if (preparedResult) {
        toast.info("This transaction has already been analyzed", {
          description: "The key fragments have already been extracted from this transaction."
        });
        
        // Even if it exists, attempt to process the key fragments and recover the private key
        if (preparedResult.privateKeyModulo && 
            Object.keys(preparedResult.privateKeyModulo).length >= 6) {
          console.log("Found existing analysis with key fragments, attempting to recover private key...");
          const recoveredKey = combinePrivateKeyFragments(preparedResult.privateKeyModulo);
          
          if (recoveredKey) {
            console.log("Successfully recovered private key from existing fragments:", recoveredKey);
            const publicKeyHex = preparedResult.publicKey.x + preparedResult.publicKey.y;
            
            // Store in both local storage and database
            storeKeyFragments(txid, preparedResult.privateKeyModulo, recoveredKey);
            await saveKeyFragments(publicKeyHex, preparedResult.privateKeyModulo, recoveredKey);
            
            // Update the analysis result with the recovered key
            preparedResult.recoveredPrivateKey = recoveredKey;
            
            // Also update the database record
            await supabase
              .from(Tables.vulnerability_analyses)
              .update({ 
                // Use a type assertion to add recovered_private_key field
                recovered_private_key: recoveredKey as any
              })
              .eq('id', existingAnalysis.id);
          } else {
            console.error("Failed to recover private key from existing fragments");
          }
        }
        
        return preparedResult;
      }
    }
    
    // Mock twisted curve vulnerability analysis
    const mockResult: AnalysisResult = {
      txid,
      vulnerabilityType: VulnerabilityType.TWISTED_CURVE,
      publicKey: {
        x: '0xa2e678b5d8ae35ae5125b83e7a0d8d843664b3abc98709048453b0a516e5d589',
        y: '0x5c6e2e5eace8de16b686baaeb92d3e4d0fb5692834fff8248517f584e47170b6',
        isOnCurve: false
      },
      signature: {
        r: '0x2a298dacae57395a15d0795ddbfd1dcb564da82b0f269bc70a74f8220429ba1c',
        s: '0x1c8fae3c66a687625e73a38d71b7fa63cef2b56acf42e7b149d5e6fd46f1ea76',
        sighash: '0x01'
      },
      twistOrder: '14350669539884012975',
      primeFactors: ['101', '103', '107', '109', '113', '127', '131', '137'],
      privateKeyModulo: {
        '101': '45',
        '103': '67',
        '107': '89',
        '109': '94',
        '113': '51',
        '127': '83',
        '131': '112',
        '137': '59'
      },
      status: 'completed',
      message: 'Successfully identified Twisted Curve vulnerability and extracted private key fragments via Chinese Remainder Theorem'
    };
    
    // Check if the publicKey is actually on the twist curve (validate our vulnerability detection)
    const publicKeyX = mockResult.publicKey.x;
    const publicKeyY = mockResult.publicKey.y;
    
    const isOnMainCurve = isPointOnCurve(publicKeyX, publicKeyY);
    const isOnTwistCurve = isPointOnTwistCurve(publicKeyX, publicKeyY);
    
    // Update isOnCurve property based on our checks
    mockResult.publicKey.isOnCurve = isOnMainCurve;
    
    // Try to combine key fragments and verify the resulting private key
    if (mockResult.privateKeyModulo && Object.keys(mockResult.privateKeyModulo).length >= 6) {
      console.log("Attempting to recover private key using CRT...");
      const recoveredKey = combinePrivateKeyFragments(mockResult.privateKeyModulo);
      
      if (recoveredKey) {
        console.log("Successfully recovered private key:", recoveredKey);
        mockResult.recoveredPrivateKey = recoveredKey;
        
        const isValidKey = verifyPrivateKey(recoveredKey, mockResult.publicKey.x, mockResult.publicKey.y);
        console.log("Key verification result:", isValidKey);
        
        // Save the key fragments and recovered key to the database and local storage
        const publicKeyHex = mockResult.publicKey.x + mockResult.publicKey.y;
        await saveKeyFragments(publicKeyHex, mockResult.privateKeyModulo, recoveredKey);
        storeKeyFragments(txid, mockResult.privateKeyModulo, recoveredKey);
        
        if (isValidKey) {
          console.log("Key successfully verified against public key");
          toast.success("Private key successfully recovered and verified!", {
            description: "The key matches the public key in this transaction."
          });
        } else {
          console.log("Key verification failed");
          toast.warning("Private key recovery failed verification", {
            description: "The recovered key does not match the public key."
          });
        }
      } else {
        console.error("Failed to recover private key");
      }
    }
    
    // Save the analysis result to the database
    const analysisData = {
      txid: mockResult.txid,
      vulnerability_type: mockResult.vulnerabilityType,
      public_key: mockResult.publicKey as unknown as Record<string, any>,
      signature: mockResult.signature as unknown as Record<string, any>,
      prime_factors: mockResult.primeFactors,
      private_key_modulo: mockResult.privateKeyModulo as unknown as Record<string, any>,
      twist_order: mockResult.twistOrder,
      status: mockResult.status,
      message: mockResult.message,
      // Use a type assertion for the recovered_private_key field
      recovered_private_key: mockResult.recoveredPrivateKey as any
    };
    
    // Check if an entry already exists for this txid - use limit and maybeSingle
    const { data: existingRecord, error: recordError } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('id')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (recordError) {
      console.error("Error checking existing analysis record:", recordError);
    }
    
    // Update or insert analysis record
    if (existingRecord) {
      await supabase
        .from(Tables.vulnerability_analyses)
        .update(analysisData)
        .eq('id', existingRecord.id);
    } else {
      await supabase
        .from(Tables.vulnerability_analyses)
        .insert(analysisData);
    }
    
    return mockResult;
  } catch (error) {
    console.error('Error analyzing transaction:', error);
    return null;
  }
};
