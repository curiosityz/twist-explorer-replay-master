import { CryptographicPoint, Signature, AnalysisResult, VulnerabilityType } from '@/types';
import { normalizeVulnerabilityAnalysis, normalizeKeyFragment } from './database';
import { 
  hexToBigInt, 
  verifyPrivateKey, 
  isPointOnCurve, 
  isPointOnTwistCurve,
  combinePrivateKeyFragments,
  curveParams,
  twistParams,
  factorize
} from './cryptoUtils';
import { solveDiscreteLog } from './crypto/discreteLogUtils';
import { supabase, Tables } from '@/integrations/supabase/client';
import { toast } from 'sonner';
import { saveKeyFragments as storeKeyFragments } from './keyStorage';
import { chainstackService } from '@/services/chainstackService';

/**
 * Normalizes analysis result data from database format
 * @param analysisData Raw analysis data from database
 * @returns Properly typed AnalysisResult object or null
 */
export const prepareAnalysisResult = (analysisData: any): AnalysisResult | null => {
  if (!analysisData) return null;
  
  const normalizedAnalysis = normalizeVulnerabilityAnalysis(analysisData);
  if (!normalizedAnalysis) return null;
  
  return {
    txid: normalizedAnalysis.txid,
    vulnerabilityType: normalizedAnalysis.vulnerability_type as VulnerabilityType,
    publicKey: normalizedAnalysis.public_key as CryptographicPoint,
    signature: normalizedAnalysis.signature as Signature,
    twistOrder: normalizedAnalysis.twist_order,
    primeFactors: normalizedAnalysis.prime_factors,
    privateKeyModulo: normalizedAnalysis.private_key_modulo || {},
    status: normalizedAnalysis.status,
    message: normalizedAnalysis.message,
    recoveredPrivateKey: normalizedAnalysis.recovered_private_key || null
  };
};

/**
 * Fetches analysis result for a transaction from the database
 * @param txid Transaction ID to fetch analysis for
 * @returns Analysis result or null if not found
 */
export const fetchAnalysisForTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    const { data: analysisData, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching analysis:', error);
      return null;
    }
    
    return prepareAnalysisResult(analysisData);
  } catch (error) {
    console.error('Error in fetchAnalysisForTransaction:', error);
    return null;
  }
};

/**
 * Fetches key fragments for a public key from the database
 * @param publicKeyHex Public key in hex format
 * @returns Key fragment data or null if not found
 */
export const fetchKeyFragmentsForPublicKey = async (publicKeyHex: string) => {
  try {
    const { data, error } = await supabase
      .from(Tables.private_key_fragments)
      .select('*')
      .eq('public_key_hex', publicKeyHex)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching key fragments:', error);
      return null;
    }
    
    return normalizeKeyFragment(data);
  } catch (error) {
    console.error('Error in fetchKeyFragmentsForPublicKey:', error);
    return null;
  }
};

/**
 * Checks if a recovered private key is valid for a given public key
 * This uses the cryptoUtils verification function but adds error handling
 * @param privateKey Recovered private key
 * @param publicKey Public key point
 * @returns Boolean indicating if key is valid and verified
 */
export const verifyRecoveredKey = (
  privateKey: string | null,
  publicKey: CryptographicPoint | undefined
): boolean => {
  if (!privateKey || !publicKey) {
    console.log("Missing key data for verification");
    return false;
  }
  
  try {
    return verifyPrivateKey(privateKey, publicKey.x, publicKey.y);
  } catch (error) {
    console.error('Error verifying recovered key:', error);
    return false;
  }
};

/**
 * Save key fragments to the database
 * @param publicKeyHex Public key in hex format
 * @param fragments Key fragments (modulo values)
 * @param combinedKey Recovered private key (if available)
 */
export const saveKeyFragments = async (
  publicKeyHex: string, 
  fragments: Record<string, string>,
  combinedKey: string | null = null
): Promise<boolean> => {
  try {
    // Check if entry already exists first to avoid conflicts
    const { data: existingEntry } = await supabase
      .from(Tables.private_key_fragments)
      .select('id')
      .eq('public_key_hex', publicKeyHex)
      .maybeSingle();
    
    const fragmentData = {
      public_key_hex: publicKeyHex,
      modulo_values: fragments,
      combined_fragments: combinedKey,
      completed: !!combinedKey
    };
    
    let result;
    
    if (existingEntry) {
      // Update existing record
      result = await supabase
        .from(Tables.private_key_fragments)
        .update(fragmentData)
        .eq('id', existingEntry.id);
    } else {
      // Insert new record
      result = await supabase
        .from(Tables.private_key_fragments)
        .insert(fragmentData);
    }
    
    if (result.error) {
      console.error("Error saving key fragments:", result.error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error("Error in saveKeyFragments:", error);
    return false;
  }
};

/**
 * Extract signature and public key from transaction data
 * @param txData Transaction data from RPC
 * @returns Extracted cryptographic data or null
 */
const extractCryptographicData = (txData: any) => {
  try {
    if (!txData || !txData.vin || txData.vin.length === 0) {
      console.log("No inputs found in transaction data");
      return null;
    }

    console.log("Transaction inputs:", txData.vin.length);
    
    // Try to extract signature and public key from each input
    for (const input of txData.vin) {
      let sigHex: string | undefined;
      let pubKeyHex: string | undefined;
      
      // Case 1: P2PKH input with scriptSig (legacy)
      if (input.scriptSig && input.scriptSig.hex) {
        console.log("Processing P2PKH input with scriptSig");
        const scriptSigHex = input.scriptSig.hex;
        
        // Find DER signature - it usually starts with 0x30
        const sigStart = scriptSigHex.indexOf('30');
        
        if (sigStart >= 0 && sigStart + 2 < scriptSigHex.length) {
          // Parse DER signature length
          const sigLengthHex = scriptSigHex.substring(sigStart + 2, sigStart + 4);
          const sigLength = parseInt(sigLengthHex, 16);
          
          // Extract signature including the 30 prefix, length byte, and data
          // Add additional bytes for DER format and SIGHASH
          const fullSigLength = (sigLength + 3) * 2; // convert bytes to hex chars
          sigHex = scriptSigHex.substring(sigStart, sigStart + fullSigLength);
          
          // Public key usually follows the signature after a push operation byte
          const pubKeyStart = sigStart + fullSigLength + 2; // +2 for push byte
          
          if (pubKeyStart < scriptSigHex.length - 2) {
            // Read public key size
            const pubKeyLengthHex = scriptSigHex.substring(pubKeyStart, pubKeyStart + 2);
            const pubKeyLength = parseInt(pubKeyLengthHex, 16) * 2; // convert bytes to hex chars
            
            // Extract public key
            pubKeyHex = scriptSigHex.substring(pubKeyStart + 2, pubKeyStart + 2 + pubKeyLength);
            
            console.log("Extracted from scriptSig - signature:", sigHex.substring(0, 16) + "...", 
                       "public key:", pubKeyHex.substring(0, 16) + "...");
          }
        }
      } 
      // Case 2: P2WPKH or P2WSH with witness data (segwit)
      else if (input.txinwitness && input.txinwitness.length >= 2) {
        console.log("Processing P2WPKH/P2WSH input with witness data");
        sigHex = input.txinwitness[0]; // First witness item is signature
        pubKeyHex = input.txinwitness[1]; // Second witness item is public key
        
        console.log("Extracted from witness - signature:", sigHex.substring(0, 16) + "...", 
                    "public key:", pubKeyHex.substring(0, 16) + "...");
      }
      
      // If we successfully extracted both signature and public key
      if (sigHex && pubKeyHex) {
        // Parse the public key
        let pubKeyX: string;
        let pubKeyY: string;
        
        // Process based on key format
        if (pubKeyHex.length >= 130 && pubKeyHex.startsWith('04')) {
          // Uncompressed key (04 + x + y)
          pubKeyX = pubKeyHex.substring(2, 66);
          pubKeyY = pubKeyHex.substring(66, 130);
        }
        else if (pubKeyHex.length >= 66 && (pubKeyHex.startsWith('02') || pubKeyHex.startsWith('03'))) {
          // Compressed key - we need to decompress to get y coordinate
          // For the MVP, we'll only handle uncompressed keys
          // In a real implementation, we'd decompress the key here
          console.log("Compressed public key detected - skipping for now");
          continue;
        }
        else {
          console.log("Unknown public key format, length:", pubKeyHex.length);
          continue;
        }
        
        // Parse the DER signature to extract r and s values
        let rValue: string;
        let sValue: string;
        
        try {
          // Very simple DER parsing - in a real implementation, we'd use a proper DER parser
          // Format is typically: [30][len][02][r_len][r][02][s_len][s][sighash_type]
          const rLength = parseInt(sigHex.substring(6, 8), 16) * 2;
          rValue = sigHex.substring(8, 8 + rLength);
          
          // s starts after r plus the type marker (02) and length byte
          const sStart = 8 + rLength + 2;
          const sLength = parseInt(sigHex.substring(sStart, sStart + 2), 16) * 2;
          sValue = sigHex.substring(sStart + 2, sStart + 2 + sLength);
          
          // Get the sighash type which should be the last byte
          const sighashType = sigHex.substring(sigHex.length - 2);
          
          // Return the extracted data
          return {
            signature: {
              r: rValue,
              s: sValue,
              sighash: sighashType
            } as Signature,
            publicKey: {
              x: pubKeyX,
              y: pubKeyY,
              isOnCurve: false // We'll check this in the analysis
            } as CryptographicPoint
          };
        } 
        catch (err) {
          console.error("Error parsing DER signature:", err);
          continue;
        }
      }
    }
    
    console.log("Failed to extract cryptographic data from any inputs");
    return null;
  } catch (error) {
    console.error("Error extracting cryptographic data:", error);
    return null;
  }
};

/**
 * Calculate prime factors for a big integer using advanced factorization algorithms
 * @param n Number to factorize
 * @returns Array of prime factors as strings
 */
const calculatePrimeFactors = (n: bigint): string[] => {
  console.log(`Calculating prime factors for: ${n} using advanced factorization`);
  
  try {
    // Use our new factorize function that leverages multiple algorithms
    const factors = factorize(n);
    
    // Log and return unique factors
    console.log(`Final unique factors: ${factors.join(', ')}`);
    return factors;
  } catch (error) {
    console.error("Error during factorization:", error);
    
    // Fallback to simpler factorization if the advanced methods fail
    const factors: bigint[] = [];
    
    // Trial division with small primes as a fallback
    const smallPrimes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 
                        43n, 47n, 53n, 59n, 61n, 67n, 71n, 73n, 79n, 83n, 89n, 97n];
    
    let num = n;
    
    for (const prime of smallPrimes) {
      while (num % prime === 0n) {
        factors.push(prime);
        num = num / prime;
      }
      
      if (num === 1n) break;
    }
    
    if (num > 1n) {
      factors.push(num); // Add any remaining factor
    }
    
    // Return unique factors
    const uniqueFactors = [...new Set(factors)];
    console.log(`Fallback factorization resulted in: ${uniqueFactors.join(', ')}`);
    
    return uniqueFactors.map(f => f.toString());
  }
};

/**
 * Calculate the private key modulo for each prime factor
 * @param primeFactors Array of prime factors as strings
 * @param point Public key point as [x, y]
 * @returns Object mapping factor to remainder
 */
const calculatePrivateKeyModulo = (
  primeFactors: string[], 
  point: [bigint, bigint]
): Record<string, string> => {
  const moduli: Record<string, string> = {};
  
  // For each prime factor, solve the discrete logarithm problem
  for (const factorStr of primeFactors) {
    const factor = BigInt(factorStr);
    
    // Solve the discrete logarithm (d ≡ x mod p) using our improved implementation
    const remainder = solveDiscreteLog(point, factor);
    
    if (remainder !== null) {
      moduli[factorStr] = remainder;
      console.log(`Found remainder for modulus ${factorStr}: ${remainder}`);
    }
  }
  
  return moduli;
};

/**
 * Check if a point is on the twist curve and analyze it for vulnerabilities
 * @param publicKey Public key point
 * @returns Analysis result object or null
 */
const analyzePublicKeyForVulnerabilities = async (
  txid: string,
  publicKey: CryptographicPoint
): Promise<AnalysisResult | null> => {
  try {
    console.log("Analyzing public key for vulnerabilities:", publicKey);
    
    // Convert hex strings to BigInt for analysis
    const x = hexToBigInt(publicKey.x);
    const y = hexToBigInt(publicKey.y);
    
    // Check if the point is on the main curve
    if (isPointOnCurve(x, y)) {
      console.log("Point is on the main curve - no twist vulnerability");
      // Store analysis result for on-curve point
      const insertData = {
        txid,
        public_key: publicKey as any,
        vulnerability_type: VulnerabilityType.NONE,
        message: "Public key is on the main curve - no twist vulnerability detected",
        status: "completed"
      };
      
      const { data, error } = await supabase
        .from(Tables.vulnerability_analyses)
        .insert(insertData)
        .select()
        .single();
        
      if (error) {
        console.error("Error storing analysis result:", error);
        return null;
      }
      
      return prepareAnalysisResult(data);
    }
    
    // Check if point is on the twist curve
    if (isPointOnTwistCurve(x, y)) {
      console.log("Point is on the twist curve - VULNERABLE!");
      
      // Calculate the twist curve order
      const twistOrder = twistParams.n.toString();
      
      // Calculate prime factors of the twist order
      const primeFactors = calculatePrimeFactors(twistParams.n);
      
      // Calculate the private key modulo each prime factor
      const privateKeyModulo = calculatePrivateKeyModulo(
        primeFactors,
        [x, y]
      );
      
      // Insert the analysis with the calculated data
      const insertData = {
        txid,
        public_key: publicKey as any,
        vulnerability_type: VulnerabilityType.TWISTED_CURVE,
        twist_order: twistOrder,
        prime_factors: primeFactors,
        private_key_modulo: privateKeyModulo,
        message: "Public key is on the twist curve - potentially vulnerable to private key recovery",
        status: "completed",
        recovered_private_key: null // Initialize with null
      };
      
      const { data, error } = await supabase
        .from(Tables.vulnerability_analyses)
        .insert(insertData)
        .select()
        .single();
        
      if (error) {
        console.error("Error storing analysis result:", error);
        return null;
      }
      
      return prepareAnalysisResult(data);
    }
    
    // Point is not on either curve
    console.log("Point is not on the main curve or twist curve - invalid key");
    const insertData = {
      txid,
      public_key: publicKey as any,
      vulnerability_type: VulnerabilityType.INVALID,
      message: "Public key is not on the main curve or twist curve - invalid point",
      status: "completed"
    };
      
    const { data, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .insert(insertData)
      .select()
      .single();
      
    if (error) {
      console.error("Error storing analysis result:", error);
      return null;
    }
    
    return prepareAnalysisResult(data);
  } catch (error) {
    console.error("Error analyzing public key:", error);
    return null;
  }
};

/**
 * Analyzes transaction for potential vulnerabilities
 * @param txid Transaction ID to analyze
 * @returns Analysis result or null if analysis failed
 */
export const analyzeTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    // Check if an analysis already exists
    const { data: existingAnalysis, error: checkError } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (checkError) {
      console.error("Error checking existing analysis:", checkError);
    } else if (existingAnalysis && existingAnalysis.vulnerability_type !== VulnerabilityType.UNKNOWN) {
      // Parse existing analysis result
      const preparedResult = prepareAnalysisResult(existingAnalysis);
      if (preparedResult) {
        toast.info("This transaction has already been analyzed", {
          description: "The key fragments have already been extracted from this transaction."
        });
        
        // Even if it exists, attempt to process the key fragments and recover the private key
        if (preparedResult.privateKeyModulo && 
            Object.keys(preparedResult.privateKeyModulo).length >= 6) {
          console.log("Found existing analysis with key fragments, attempting to recover private key...");
          const recoveredKey = combinePrivateKeyFragments(preparedResult.privateKeyModulo);
          
          if (recoveredKey) {
            console.log("Successfully recovered private key from existing fragments:", recoveredKey);
            const publicKeyHex = preparedResult.publicKey.x + preparedResult.publicKey.y;
            
            // Store in both local storage and database
            storeKeyFragments(txid, preparedResult.privateKeyModulo, recoveredKey);
            await saveKeyFragments(publicKeyHex, preparedResult.privateKeyModulo, recoveredKey);
            
            // Update the analysis with the recovered key
            preparedResult.recoveredPrivateKey = recoveredKey;
            
            // Also update the database record
            const updateResult = await supabase
              .from(Tables.vulnerability_analyses)
              .update({
                recovered_private_key: recoveredKey
              })
              .eq('id', existingAnalysis.id);
              
            if (updateResult.error) {
              console.error("Error updating analysis with recovered key:", updateResult.error);
            }
          } else {
            console.error("Failed to recover private key from existing fragments");
          }
        }
        
        return preparedResult;
      }
    }
    
    // Perform real-time analysis on the blockchain data
    toast.loading("Analyzing transaction for vulnerabilities...", {
      id: "analyzing-transaction"
    });
    
    try {
      // Fetch the transaction data from the blockchain via RPC
      console.log("Fetching transaction data for:", txid);
      const txData = await chainstackService.getTransaction(txid);
      
      if (!txData) {
        toast.dismiss("analyzing-transaction");
        toast.error("Failed to fetch transaction data", { 
          description: "Could not retrieve the transaction from the blockchain" 
        });
        return null;
      }
      
      console.log("Successfully retrieved transaction data");
      
      // Extract the public key and signature from the transaction
      const cryptoData = extractCryptographicData(txData);
      
      if (!cryptoData) {
        toast.dismiss("analyzing-transaction");
        toast.error("Failed to extract cryptographic data", { 
          description: "Could not find a valid signature and public key in this transaction" 
        });
        
        // Store a record of the failed analysis
        await supabase
          .from(Tables.vulnerability_analyses)
          .insert({
            txid,
            public_key: { x: "0", y: "0", isOnCurve: false } as any,
            vulnerability_type: VulnerabilityType.UNKNOWN,
            message: "Could not extract cryptographic data from transaction",
            status: "failed"
          });
          
        return null;
      }
      
      console.log("Successfully extracted cryptographic data:", {
        publicKeyX: cryptoData.publicKey.x.substring(0, 16) + "...",
        publicKeyY: cryptoData.publicKey.y.substring(0, 16) + "..."
      });
      
      // Analyze the public key for vulnerabilities using full implementation
      const result = await analyzePublicKeyForVulnerabilities(txid, cryptoData.publicKey);
      
      toast.dismiss("analyzing-transaction");
      
      if (result) {
        if (result.vulnerabilityType === VulnerabilityType.TWISTED_CURVE) {
          toast.success("Vulnerability detected!", {
            description: "This transaction contains a public key on the twist curve"
          });
          
          // If we have enough key fragments, try to recover the private key immediately
          if (result.privateKeyModulo && Object.keys(result.privateKeyModulo).length >= 6) {
            console.log("Attempting to recover private key from fragments...");
            const recoveredKey = combinePrivateKeyFragments(result.privateKeyModulo);
            
            if (recoveredKey) {
              console.log("Successfully recovered private key:", recoveredKey);
              
              // Verify the key against the public key
              const isValid = verifyPrivateKey(
                recoveredKey,
                cryptoData.publicKey.x,
                cryptoData.publicKey.y
              );
              
              if (isValid) {
                console.log("Verified recovered private key is valid!");
                
                // Update the analysis with the recovered key
                const updateResult = await supabase
                  .from(Tables.vulnerability_analyses)
                  .update({
                    recovered_private_key: recoveredKey
                  })
                  .eq('txid', txid);
                  
                if (updateResult.error) {
                  console.error("Error updating analysis with recovered key:", updateResult.error);
                } else {
                  result.recoveredPrivateKey = recoveredKey;
                  toast.success("Private key successfully recovered!", {
                    description: "The private key for this public key has been recovered."
                  });
                }
              } else {
                console.error("Recovered key failed verification");
                toast.error("Key recovery verification failed", {
                  description: "The recovered private key failed verification."
                });
              }
            }
          }
        } else {
          toast.info("Analysis complete", {
            description: `Result: ${result.vulnerabilityType}`
          });
        }
      }
      
      return result;
    } catch (error) {
      console.error("Error in blockchain analysis:", error);
      toast.dismiss("analyzing-transaction");
      toast.error("Failed to analyze blockchain data", {
        description: error instanceof Error ? error.message : "Unknown error"
      });
      
      return null;
    }
  } catch (error) {
    console.error('Error analyzing transaction:', error);
    toast.dismiss("analyzing-transaction");
    toast.error("Failed to analyze transaction");
    return null;
  }
};
