
/**
 * Utilities for analyzing and managing cryptographic vulnerabilities
 */
import { CryptographicPoint, Signature, AnalysisResult, VulnerabilityType } from '@/types';
import { normalizeVulnerabilityAnalysis, normalizeKeyFragment } from './database';
import { 
  hexToBigInt, 
  verifyPrivateKey, 
  isPointOnCurve, 
  isPointOnTwistCurve,
  combinePrivateKeyFragments
} from './cryptoUtils';
import { supabase, Tables } from '@/integrations/supabase/client';
import { toast } from 'sonner';
import { saveKeyFragments as storeKeyFragments } from './keyStorage';

/**
 * Normalizes analysis result data from database format
 * @param analysisData Raw analysis data from database
 * @returns Properly typed AnalysisResult object or null
 */
export const prepareAnalysisResult = (analysisData: any): AnalysisResult | null => {
  if (!analysisData) return null;
  
  const normalizedAnalysis = normalizeVulnerabilityAnalysis(analysisData);
  if (!normalizedAnalysis) return null;
  
  return {
    txid: normalizedAnalysis.txid,
    vulnerabilityType: normalizedAnalysis.vulnerability_type,
    publicKey: normalizedAnalysis.public_key as CryptographicPoint,
    signature: normalizedAnalysis.signature as Signature,
    twistOrder: normalizedAnalysis.twist_order,
    primeFactors: normalizedAnalysis.prime_factors,
    privateKeyModulo: normalizedAnalysis.private_key_modulo || {},
    status: normalizedAnalysis.status,
    message: normalizedAnalysis.message
  };
};

/**
 * Fetches analysis result for a transaction from the database
 * @param txid Transaction ID to fetch analysis for
 * @returns Analysis result or null if not found
 */
export const fetchAnalysisForTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    const { data: analysisData, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching analysis:', error);
      return null;
    }
    
    return prepareAnalysisResult(analysisData);
  } catch (error) {
    console.error('Error in fetchAnalysisForTransaction:', error);
    return null;
  }
};

/**
 * Fetches key fragments for a public key from the database
 * @param publicKeyHex Public key in hex format
 * @returns Key fragment data or null if not found
 */
export const fetchKeyFragmentsForPublicKey = async (publicKeyHex: string) => {
  try {
    const { data, error } = await supabase
      .from(Tables.private_key_fragments)
      .select('*')
      .eq('public_key_hex', publicKeyHex)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching key fragments:', error);
      return null;
    }
    
    return normalizeKeyFragment(data);
  } catch (error) {
    console.error('Error in fetchKeyFragmentsForPublicKey:', error);
    return null;
  }
};

/**
 * Checks if a recovered private key is valid for a given public key
 * This uses the cryptoUtils verification function but adds error handling
 * @param privateKey Recovered private key
 * @param publicKey Public key point
 * @returns Boolean indicating if key is valid and verified
 */
export const verifyRecoveredKey = (
  privateKey: string | null,
  publicKey: CryptographicPoint | undefined
): boolean => {
  if (!privateKey || !publicKey) {
    console.log("Missing key data for verification");
    return false;
  }
  
  try {
    // First check if the public key is actually on either the main curve or twist curve
    const isOnMainCurve = isPointOnCurve(publicKey.x, publicKey.y);
    const isOnTwistCurve = isPointOnTwistCurve(publicKey.x, publicKey.y);
    
    if (!isOnMainCurve && !isOnTwistCurve) {
      console.error("Public key is not on either the main curve or twist curve");
      return false;
    }
    
    // Now verify the private key
    return verifyPrivateKey(privateKey, publicKey.x, publicKey.y);
  } catch (error) {
    console.error('Error verifying recovered key:', error);
    return false;
  }
};

/**
 * Save key fragments to the database
 * @param publicKeyHex Public key in hex format
 * @param fragments Key fragments (modulo values)
 * @param combinedKey Recovered private key (if available)
 */
export const saveKeyFragments = async (
  publicKeyHex: string, 
  fragments: Record<string, string>,
  combinedKey: string | null = null
): Promise<boolean> => {
  try {
    const fragmentData = {
      public_key_hex: publicKeyHex,
      modulo_values: fragments,
      combined_fragments: combinedKey,
      completed: !!combinedKey
    };
    
    const { error } = await supabase
      .from(Tables.private_key_fragments)
      .upsert(fragmentData);
      
    if (error) {
      console.error("Error saving key fragments:", error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error("Error in saveKeyFragments:", error);
    return false;
  }
};

/**
 * Analyzes transaction for potential vulnerabilities
 * @param txid Transaction ID to analyze
 * @returns Analysis result or null if analysis failed
 */
export const analyzeTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    // Check if an analysis already exists
    const existingAnalysis = await fetchAnalysisForTransaction(txid);
    if (existingAnalysis && existingAnalysis.vulnerabilityType !== VulnerabilityType.UNKNOWN) {
      toast.info("This transaction has already been analyzed", {
        description: "The key fragments have already been extracted from this transaction."
      });
      
      // Even if it exists, attempt to process the key fragments and recover the private key
      if (existingAnalysis.privateKeyModulo && 
          Object.keys(existingAnalysis.privateKeyModulo).length >= 6) {
        console.log("Found existing analysis with key fragments, attempting to recover private key...");
        const recoveredKey = combinePrivateKeyFragments(existingAnalysis.privateKeyModulo);
        
        if (recoveredKey) {
          console.log("Successfully recovered private key from existing fragments:", recoveredKey);
          const publicKeyHex = existingAnalysis.publicKey.x + existingAnalysis.publicKey.y;
          
          // Store in both local storage and database
          storeKeyFragments(txid, existingAnalysis.privateKeyModulo, recoveredKey);
          await saveKeyFragments(publicKeyHex, existingAnalysis.privateKeyModulo, recoveredKey);
          
          // Update the analysis result with the recovered key
          existingAnalysis.recoveredPrivateKey = recoveredKey;
        } else {
          console.error("Failed to recover private key from existing fragments");
        }
      }
      
      return existingAnalysis;
    }
    
    // In a real implementation, this would perform actual cryptographic analysis on the transaction data
    // For this demonstration, we'll continue to use mock data but with our improved cryptographic logic
    
    // Mock twisted curve vulnerability analysis
    const mockResult: AnalysisResult = {
      txid,
      vulnerabilityType: VulnerabilityType.TWISTED_CURVE,
      publicKey: {
        x: '0xa2e678b5d8ae35ae5125b83e7a0d8d843664b3abc98709048453b0a516e5d589',
        y: '0x5c6e2e5eace8de16b686baaeb92d3e4d0fb5692834fff8248517f584e47170b6',
        isOnCurve: false
      },
      signature: {
        r: '0x2a298dacae57395a15d0795ddbfd1dcb564da82b0f269bc70a74f8220429ba1c',
        s: '0x1c8fae3c66a687625e73a38d71b7fa63cef2b56acf42e7b149d5e6fd46f1ea76',
        sighash: '0x01'
      },
      twistOrder: '14350669539884012975',
      primeFactors: ['101', '103', '107', '109', '113', '127', '131', '137'],
      privateKeyModulo: {
        '101': '45',
        '103': '67',
        '107': '89',
        '109': '94',
        '113': '51',
        '127': '83',
        '131': '112',
        '137': '59'
      },
      status: 'completed',
      message: 'Successfully identified Twisted Curve vulnerability and extracted private key fragments via Chinese Remainder Theorem'
    };
    
    // Check if the publicKey is actually on the twist curve (validate our vulnerability detection)
    const publicKeyX = mockResult.publicKey.x;
    const publicKeyY = mockResult.publicKey.y;
    
    const isOnMainCurve = isPointOnCurve(publicKeyX, publicKeyY);
    const isOnTwistCurve = isPointOnTwistCurve(publicKeyX, publicKeyY);
    
    // Update isOnCurve property based on our checks
    mockResult.publicKey.isOnCurve = isOnMainCurve;
    
    // Try to combine key fragments and verify the resulting private key
    if (mockResult.privateKeyModulo && Object.keys(mockResult.privateKeyModulo).length >= 6) {
      console.log("Attempting to recover private key using CRT...");
      const recoveredKey = combinePrivateKeyFragments(mockResult.privateKeyModulo);
      
      if (recoveredKey) {
        console.log("Successfully recovered private key:", recoveredKey);
        mockResult.recoveredPrivateKey = recoveredKey;
        
        const isValidKey = verifyPrivateKey(recoveredKey, publicKeyX, publicKeyY);
        console.log("Key verification result:", isValidKey);
        
        // Save the key fragments and recovered key to the database and local storage
        const publicKeyHex = publicKeyX + publicKeyY;
        await saveKeyFragments(publicKeyHex, mockResult.privateKeyModulo, recoveredKey);
        storeKeyFragments(txid, mockResult.privateKeyModulo, recoveredKey);
        
        if (isValidKey) {
          console.log("Key successfully verified against public key");
          toast.success("Private key successfully recovered and verified!", {
            description: "The key matches the public key in this transaction."
          });
        } else {
          console.log("Key verification failed");
          toast.warning("Private key recovery failed verification", {
            description: "The recovered key does not match the public key."
          });
        }
      } else {
        console.error("Failed to recover private key");
      }
    }
    
    // Save the analysis result to the database
    const analysisData = {
      txid: mockResult.txid,
      vulnerability_type: mockResult.vulnerabilityType,
      public_key: mockResult.publicKey as unknown as Record<string, any>,
      signature: mockResult.signature as unknown as Record<string, any>,
      prime_factors: mockResult.primeFactors,
      private_key_modulo: mockResult.privateKeyModulo as unknown as Record<string, any>,
      twist_order: mockResult.twistOrder,
      status: mockResult.status,
      message: mockResult.message,
      recovered_private_key: mockResult.recoveredPrivateKey
    };
    
    // Check if an entry already exists for this txid
    const { data: existingRecord, error: checkError } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('id')
      .eq('txid', txid)
      .maybeSingle();
    
    if (checkError) {
      console.error("Error checking existing analysis:", checkError);
    }
    
    // Update or insert analysis record
    if (existingRecord) {
      await supabase
        .from(Tables.vulnerability_analyses)
        .update(analysisData)
        .eq('id', existingRecord.id);
    } else {
      await supabase
        .from(Tables.vulnerability_analyses)
        .insert(analysisData);
    }
    
    return mockResult;
  } catch (error) {
    console.error('Error analyzing transaction:', error);
    return null;
  }
};
