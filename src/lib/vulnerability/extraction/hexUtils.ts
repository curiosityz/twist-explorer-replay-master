
/**
 * Hex conversion utilities for cryptographic data
 */

/**
 * Convert bytes to hex string
 * @param bytes Byte array or buffer
 * @returns Hex string
 */
export const bytesToHex = (bytes: Uint8Array | number[] | Buffer): string => {
  return Array.from(bytes)
    .map(byte => byte.toString(16).padStart(2, '0'))
    .join('');
};

/**
 * Convert hex string to bytes
 * @param hex Hex string
 * @returns Byte array
 */
export const hexToBytes = (hex: string): Uint8Array => {
  // Remove 0x prefix if present
  const cleanHex = hex.startsWith('0x') ? hex.substring(2) : hex;
  
  // Ensure even number of characters
  const paddedHex = cleanHex.length % 2 === 0 ? cleanHex : '0' + cleanHex;
  
  const bytes = new Uint8Array(paddedHex.length / 2);
  for (let i = 0; i < paddedHex.length; i += 2) {
    bytes[i/2] = parseInt(paddedHex.substring(i, i+2), 16);
  }
  
  return bytes;
};

/**
 * Extract cryptographic data from transaction hex
 * This is a fallback method when structured extraction methods fail
 * 
 * @param txData Transaction data containing raw hex
 * @returns Object with public key and signature if found, null otherwise
 */
export const extractHexData = (txData: any) => {
  try {
    // Check if there's raw hex data to work with
    if (!txData.hex) {
      console.warn('No hex data available in transaction');
      return null;
    }

    const hex = txData.hex;
    
    // Look for public key patterns in the hex
    // This is a simplified approach - in a real scenario, we'd need more sophisticated parsing
    
    // Try to find uncompressed public keys (0x04 prefix followed by 64 bytes)
    const uncompressedKeyRegex = /04([0-9a-f]{128})/gi;
    const uncompressedMatches = hex.match(uncompressedKeyRegex);
    
    if (uncompressedMatches && uncompressedMatches.length > 0) {
      // Extract first match and parse x, y coordinates
      const keyHex = uncompressedMatches[0].substring(2); // Remove 04 prefix
      const x = keyHex.substring(0, 64);
      const y = keyHex.substring(64, 128);
      
      console.log('Extracted uncompressed public key from hex');
      
      return {
        publicKey: {
          x,
          y,
          isOnCurve: true // We assume it's on curve, would need validation
        },
        signature: {
          r: '0', // Placeholder, would need actual signature parsing
          s: '0',
          sighash: '01'
        }
      };
    }
    
    // Try to find compressed public keys (0x02 or 0x03 prefix followed by 32 bytes)
    const compressedKeyRegex = /0[23]([0-9a-f]{64})/gi;
    const compressedMatches = hex.match(compressedKeyRegex);
    
    if (compressedMatches && compressedMatches.length > 0) {
      // Would need to decompress the key to get y coordinate
      // Simplified approach for now
      const x = compressedMatches[0].substring(2);
      
      console.log('Found compressed public key in hex, but decompression requires secp256k1');
      
      return {
        publicKey: {
          x,
          y: '0', // Would need decompression
          isOnCurve: true
        },
        signature: {
          r: '0', // Placeholder
          s: '0',
          sighash: '01'
        }
      };
    }
    
    console.warn('Could not extract cryptographic data from hex');
    return null;
  } catch (error) {
    console.error('Error extracting data from hex:', error);
    return null;
  }
};
