
/**
 * Utility functions for handling hex data
 */

/**
 * Convert a Uint8Array to a hex string
 * @param bytes The bytes to convert
 * @returns Hex string representation
 */
export const bytesToHex = (bytes: Uint8Array | number[]): string => {
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
};

/**
 * Convert a hex string to Uint8Array
 * @param hex The hex string to convert
 * @returns Byte array
 */
export const hexToBytes = (hex: string): Uint8Array => {
  // Remove 0x prefix if present
  const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
  
  // Ensure even length
  const paddedHex = cleanHex.length % 2 === 0 ? cleanHex : '0' + cleanHex;
  
  const bytes = new Uint8Array(paddedHex.length / 2);
  
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(paddedHex.substring(i * 2, i * 2 + 2), 16);
  }
  
  return bytes;
};

/**
 * Extract raw data from a hex string
 * @param data Input data (hex string, object with hex property, etc)
 * @returns Extracted hex string or null
 */
export const extractHexData = (data: any): any => {
  if (!data) return null;
  
  // If it's already a string, assume it's hex
  if (typeof data === 'string') {
    return data;
  }
  
  // Check common patterns for hex data in objects
  if (data.hex && typeof data.hex === 'string') {
    return data.hex;
  }
  
  if (data.data && typeof data.data === 'string') {
    return data.data;
  }
  
  if (data.raw && typeof data.raw === 'string') {
    return data.raw;
  }
  
  // Try to find nested hex data
  if (data.scriptSig && data.scriptSig.hex) {
    return data.scriptSig.hex;
  }
  
  if (data.script && typeof data.script === 'string') {
    return data.script;
  }
  
  // Specific format handling
  if (data.vin && Array.isArray(data.vin) && data.vin.length > 0) {
    const vin = data.vin[0];
    if (vin.scriptSig && vin.scriptSig.hex) {
      return vin.scriptSig.hex;
    }
  }
  
  // Recursive descent for complex objects (limited depth for safety)
  for (const key in data) {
    if (typeof data[key] === 'object' && data[key] !== null) {
      const result = extractHexData(data[key]);
      if (result) return result;
    }
  }
  
  return null;
};

/**
 * Check if a string is a valid hex string
 * @param str The string to check
 * @returns Boolean indicating if it's a valid hex string
 */
export const isHexString = (str: string): boolean => {
  if (!str || typeof str !== 'string') return false;
  return /^(0x)?[0-9a-fA-F]+$/.test(str);
};
