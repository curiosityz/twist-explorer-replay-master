
/**
 * Utilities for extracting cryptographic data from raw hex
 */

/**
 * Extract cryptographic data from transaction hex
 * This is a fallback method when structured extraction methods fail
 * 
 * @param txData Transaction data containing raw hex
 * @returns Object with public key and signature if found, null otherwise
 */
export const extractHexData = (txData: any) => {
  try {
    // Check if there's raw hex data to work with
    if (!txData.hex) {
      console.warn('No hex data available in transaction');
      return null;
    }

    const hex = txData.hex;
    
    // Look for public key patterns in the hex
    // This is a simplified approach - in a real scenario, we'd need more sophisticated parsing
    
    // Try to find uncompressed public keys (0x04 prefix followed by 64 bytes)
    const uncompressedKeyRegex = /04([0-9a-f]{128})/gi;
    const uncompressedMatches = hex.match(uncompressedKeyRegex);
    
    if (uncompressedMatches && uncompressedMatches.length > 0) {
      // Extract first match and parse x, y coordinates
      const keyHex = uncompressedMatches[0].substring(2); // Remove 04 prefix
      const x = `0x${keyHex.substring(0, 64)}`;
      const y = `0x${keyHex.substring(64, 128)}`;
      
      console.log('Extracted uncompressed public key from hex');
      
      return {
        publicKey: {
          x,
          y,
          isOnCurve: true // We assume it's on curve, would need validation
        },
        signature: {
          r: '0x0', // Placeholder, would need actual signature parsing
          s: '0x0',
          sighash: '01'
        }
      };
    }
    
    // Try to find compressed public keys (0x02 or 0x03 prefix followed by 32 bytes)
    const compressedKeyRegex = /0[23]([0-9a-f]{64})/gi;
    const compressedMatches = hex.match(compressedKeyRegex);
    
    if (compressedMatches && compressedMatches.length > 0) {
      // Would need to decompress the key to get y coordinate
      // Simplified approach for now
      const x = `0x${compressedMatches[0].substring(2)}`;
      
      console.log('Found compressed public key in hex, but decompression requires secp256k1');
      
      return {
        publicKey: {
          x,
          y: '0x0', // Would need decompression
          isOnCurve: true
        },
        signature: {
          r: '0x0', // Placeholder
          s: '0x0',
          sighash: '01'
        }
      };
    }
    
    console.warn('Could not extract cryptographic data from hex');
    return null;
  } catch (error) {
    console.error('Error extracting data from hex:', error);
    return null;
  }
};
