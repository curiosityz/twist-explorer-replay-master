
/**
 * Utility functions for extracting cryptographic data from raw transaction hex
 */

import { CryptographicPoint, Signature } from '@/types';
import { decodeDERSignature } from '@/lib/crypto/signatureUtils';

/**
 * Convert bytes array to hex string
 * @param bytes Array or Uint8Array of bytes
 * @returns Hex string representation
 */
export const bytesToHex = (bytes: Uint8Array | number[]): string => {
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
};

/**
 * Convert hex string to bytes array
 * @param hex Hex string
 * @returns Uint8Array of bytes
 */
export const hexToBytes = (hex: string): Uint8Array => {
  const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i/2] = parseInt(cleanHex.substr(i, 2), 16);
  }
  return bytes;
};

/**
 * Extract public key and signature from raw transaction hex
 * This is a fallback method when P2PKH and SegWit extraction fail
 * @param txData Transaction data (raw hex or object containing hex)
 * @returns Object with signature and public key if found, null otherwise
 */
export const extractHexData = (txData: any): { signature: Signature, publicKey: CryptographicPoint } | null => {
  try {
    // Extract raw hex from transaction data
    const rawHex = extractRawHex(txData);
    if (!rawHex) {
      console.error("No raw hex found in transaction data");
      return null;
    }
    
    console.log("Attempting to extract cryptographic data from raw hex...");
    
    // Look for potential DER signature (starts with 0x30)
    const sigMatch = findDERSignature(rawHex);
    if (!sigMatch) {
      console.error("No DER signature found in raw hex");
      return null;
    }
    
    // Look for potential public key 
    // Compressed keys start with 02 or 03 and are 33 bytes (66 hex chars)
    // Uncompressed keys start with 04 and are 65 bytes (130 hex chars)
    const pubKeyMatch = findPublicKey(rawHex);
    if (!pubKeyMatch) {
      console.error("No public key found in raw hex");
      return null;
    }
    
    console.log("Found potential signature and public key in raw hex");
    
    // Parse signature
    const signatureResult = parseDERSignature(sigMatch);
    if (!signatureResult) {
      console.error("Failed to parse DER signature");
      return null;
    }
    
    // Parse public key
    const publicKeyResult = parsePublicKey(pubKeyMatch);
    if (!publicKeyResult) {
      console.error("Failed to parse public key");
      return null;
    }
    
    return {
      signature: signatureResult,
      publicKey: publicKeyResult
    };
    
  } catch (error) {
    console.error("Error extracting hex data:", error);
    return null;
  }
};

/**
 * Extract raw hex from transaction data
 * @param txData Transaction data
 * @returns Raw hex string or null
 */
const extractRawHex = (txData: any): string | null => {
  // Case 1: Direct hex string
  if (typeof txData === 'string' && /^[0-9a-fA-F]+$/.test(txData)) {
    return txData;
  }
  
  // Case 2: Transaction object with hex property
  if (txData && typeof txData.hex === 'string') {
    return txData.hex;
  }
  
  // Case 3: Raw hex inside decoded_json
  if (txData && txData.decoded_json) {
    const decoded = typeof txData.decoded_json === 'string' 
      ? JSON.parse(txData.decoded_json) 
      : txData.decoded_json;
    
    if (decoded && typeof decoded.hex === 'string') {
      return decoded.hex;
    }
  }
  
  // Case 4: Raw hex in any vin scriptSig
  if (txData && txData.vin && Array.isArray(txData.vin)) {
    for (const input of txData.vin) {
      if (input.scriptSig && typeof input.scriptSig.hex === 'string') {
        return input.scriptSig.hex;
      }
    }
  }
  
  // Case 5: Raw hex in txinwitness
  if (txData && txData.vin && Array.isArray(txData.vin)) {
    for (const input of txData.vin) {
      if (input.txinwitness && Array.isArray(input.txinwitness)) {
        // Return the longest witness item as it's likely to contain the signature and public key
        let longestWitness = '';
        for (const witness of input.txinwitness) {
          if (typeof witness === 'string' && witness.length > longestWitness.length) {
            longestWitness = witness;
          }
        }
        if (longestWitness) {
          return longestWitness;
        }
      }
    }
  }
  
  return null;
};

/**
 * Find a DER signature in raw hex
 * @param rawHex Raw hex string
 * @returns Potential DER signature or null
 */
const findDERSignature = (rawHex: string): string | null => {
  // DER signatures start with 0x30 followed by length
  const derRegex = /30([0-9a-f]{2})([0-9a-f]{2,200})/i;
  const match = rawHex.match(derRegex);
  
  if (match) {
    const length = parseInt(match[1], 16);
    // Extract the full signature including the 0x30 and length byte
    const signature = match[0].substring(0, (length + 2) * 2);
    
    // Basic validation - should have at least 68 characters (minimum DER sig)
    if (signature.length >= 68) {
      return signature;
    }
  }
  
  return null;
};

/**
 * Find a public key in raw hex
 * @param rawHex Raw hex string
 * @returns Potential public key or null
 */
const findPublicKey = (rawHex: string): string | null => {
  // Look for compressed public key (starts with 02 or 03, followed by 64 hex chars)
  const compressedRegex = /(02|03)([0-9a-f]{64})/i;
  let match = rawHex.match(compressedRegex);
  
  if (match) {
    return match[0];
  }
  
  // Look for uncompressed public key (starts with 04, followed by 128 hex chars)
  const uncompressedRegex = /04([0-9a-f]{128})/i;
  match = rawHex.match(uncompressedRegex);
  
  if (match) {
    return match[0];
  }
  
  return null;
};

/**
 * Parse a DER signature
 * @param derHex DER signature hex
 * @returns Signature object or null
 */
const parseDERSignature = (derHex: string): Signature | null => {
  try {
    const { r, s } = decodeDERSignature(derHex);
    
    // Add a default sighash type
    return {
      r,
      s,
      sighash: "01" // SIGHASH_ALL is the default
    };
  } catch (error) {
    console.error("Error parsing DER signature:", error);
    return null;
  }
};

/**
 * Parse a public key
 * @param pubKeyHex Public key hex
 * @returns Public key object or null
 */
const parsePublicKey = (pubKeyHex: string): CryptographicPoint | null => {
  try {
    // Check if compressed (starts with 02 or 03) or uncompressed (starts with 04)
    if (pubKeyHex.startsWith('02') || pubKeyHex.startsWith('03')) {
      // Compressed key - need to decompress to get y coordinate
      // For now, just set a placeholder Y for testing
      return {
        x: pubKeyHex.substring(2),
        y: '1', // Placeholder, should be decompressed properly
        isOnCurve: false // We don't know yet if it's on the curve
      };
    } else if (pubKeyHex.startsWith('04')) {
      // Uncompressed key - extract x and y directly
      const x = pubKeyHex.substring(2, 66);
      const y = pubKeyHex.substring(66, 130);
      
      return {
        x,
        y,
        isOnCurve: false // We don't know yet if it's on the curve
      };
    }
    
    return null;
  } catch (error) {
    console.error("Error parsing public key:", error);
    return null;
  }
};
