
/**
 * Hex encoding/decoding utilities
 */

/**
 * Convert bytes array to hex string
 * @param bytes Uint8Array to convert to hex
 * @returns Hex string representation
 */
export const bytesToHex = (bytes: Uint8Array): string => {
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
};

/**
 * Convert hex string to bytes array
 * @param hex Hex string to convert to bytes
 * @returns Uint8Array representation
 */
export const hexToBytes = (hex: string): Uint8Array => {
  // Remove 0x prefix if present
  const cleanHex = hex.startsWith('0x') ? hex.slice(2) : hex;
  
  // Handle odd-length hex strings by padding with a leading zero
  const paddedHex = cleanHex.length % 2 === 0 ? cleanHex : '0' + cleanHex;
  
  const bytes = new Uint8Array(paddedHex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(paddedHex.substring(i * 2, i * 2 + 2), 16);
  }
  return bytes;
};

/**
 * Extract cryptographic data from raw transaction hex
 * @param txData Transaction data containing hex representation
 * @returns Object with extracted signature and public key if found
 */
export const extractHexData = (txData: any): any => {
  try {
    // Check if transaction contains a hex field
    let txHex = '';
    
    if (typeof txData === 'string' && txData.match(/^[0-9a-fA-F]+$/)) {
      // Direct hex string
      txHex = txData;
    } else if (txData && typeof txData.hex === 'string') {
      txHex = txData.hex;
    } else if (txData && txData.vin && txData.vin[0] && 
              (txData.vin[0].scriptSig?.hex || txData.vin[0].witness)) {
      // Try to get from specific fields
      txHex = txData.vin[0].scriptSig?.hex || txData.vin[0].witness;
    }
    
    if (!txHex || txHex.length < 10) {
      console.error("No valid hex data found in transaction");
      return null;
    }
    
    // Look for potential public key patterns in the hex
    // Uncompressed public key starts with 04 followed by 64 bytes (128 hex chars)
    const uncompressedKeyPattern = /04[a-fA-F0-9]{128}/g;
    // Compressed public key starts with 02 or 03 followed by 32 bytes (64 hex chars)
    const compressedKeyPattern = /0[23][a-fA-F0-9]{64}/g;
    
    let publicKey = null;
    let uncompressedMatches = txHex.match(uncompressedKeyPattern);
    let compressedMatches = txHex.match(compressedKeyPattern);
    
    if (uncompressedMatches && uncompressedMatches.length > 0) {
      // Found uncompressed public key
      const keyHex = uncompressedMatches[0];
      publicKey = {
        x: keyHex.substring(2, 66),
        y: keyHex.substring(66, 130),
        isOnCurve: true // We'll assume it's on the curve
      };
    } else if (compressedMatches && compressedMatches.length > 0) {
      // Found compressed public key, but we need to decompress it
      const keyHex = compressedMatches[0];
      
      // Attempt to decompress using secp256k1 if available
      if (window.secp256k1) {
        try {
          const compressedBytes = hexToBytes(keyHex);
          const uncompressedBytes = window.secp256k1.publicKeyConvert(compressedBytes, false);
          
          // Format should be: 04 | x (32 bytes) | y (32 bytes)
          const xHex = bytesToHex(uncompressedBytes.slice(1, 33));
          const yHex = bytesToHex(uncompressedBytes.slice(33, 65));
          
          publicKey = {
            x: xHex,
            y: yHex,
            isOnCurve: true
          };
        } catch (error) {
          console.error("Failed to decompress public key:", error);
        }
      }
    }
    
    if (!publicKey) {
      console.error("Could not find valid public key in hex data");
      return null;
    }
    
    // Look for DER signature pattern
    // DER signatures start with 30 followed by length byte
    const derSigPattern = /30[0-9a-fA-F]{2}02[0-9a-fA-F]{2}[0-9a-fA-F]+02[0-9a-fA-F]{2}[0-9a-fA-F]+/g;
    const sigMatches = txHex.match(derSigPattern);
    
    if (!sigMatches || sigMatches.length === 0) {
      console.error("Could not find DER signature in hex data");
      // Return public key only if we can't find the signature
      return { 
        publicKey,
        signature: {
          r: "0".repeat(64),
          s: "0".repeat(64),
          sighash: "01"
        }
      };
    }
    
    // Try to parse the signature
    const sigHex = sigMatches[0];
    try {
      // Parse manually
      let pos = 2; // Skip '30' marker
      const totalLen = parseInt(sigHex.substring(pos, pos + 2), 16);
      pos += 2;
      
      if (sigHex.substring(pos, pos + 2) !== '02') {
        throw new Error('Invalid DER signature: missing first integer marker');
      }
      pos += 2;
      
      const rLen = parseInt(sigHex.substring(pos, pos + 2), 16);
      pos += 2;
      let rHex = sigHex.substring(pos, pos + rLen * 2);
      if (rHex.length < 64) rHex = rHex.padStart(64, '0');
      pos += rLen * 2;
      
      if (sigHex.substring(pos, pos + 2) !== '02') {
        throw new Error('Invalid DER signature: missing second integer marker');
      }
      pos += 2;
      
      const sLen = parseInt(sigHex.substring(pos, pos + 2), 16);
      pos += 2;
      let sHex = sigHex.substring(pos, pos + sLen * 2);
      if (sHex.length < 64) sHex = sHex.padStart(64, '0');
      
      return {
        publicKey,
        signature: {
          r: rHex,
          s: sHex,
          sighash: "01" // Assume SIGHASH_ALL as default
        }
      };
    } catch (error) {
      console.error("Failed to parse DER signature:", error);
      // Return public key only if we can't parse the signature
      return { 
        publicKey,
        signature: {
          r: "0".repeat(64),
          s: "0".repeat(64),
          sighash: "01"
        }
      };
    }
  } catch (error) {
    console.error("Error extracting data from hex:", error);
    return null;
  }
};
