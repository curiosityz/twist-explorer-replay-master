
/**
 * Main export file for cryptographic data extraction utilities
 */

import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoin-libs/check-status';
import { extractP2PKHData } from './p2pkh';
import { extractSegWitData } from './segwit';
import { extractHexData, bytesToHex, hexToBytes } from './hexUtils';

/**
 * Extract cryptographic data (public key and signature) from transaction
 * @param txData Transaction data from blockchain API
 * @returns Object containing public key and signature if found, or null if not found
 */
export const extractCryptographicData = (txData: any) => {
  try {
    console.log("Starting cryptographic data extraction...");
    
    if (!txData) {
      console.error("Cannot extract data: Transaction data is null or undefined");
      return null;
    }
    
    // First check if Bitcoin libraries are available for optimal extraction
    const libsCheck = checkBitcoinLibsLoaded();
    console.log("Found Bitcoin libraries:", libsCheck);
    
    // Make a copy of the transaction data to avoid reference issues
    let txDataCopy: any;
    try {
      txDataCopy = typeof txData === 'object' ? 
        JSON.parse(JSON.stringify(txData)) : 
        (typeof txData === 'string' ? JSON.parse(txData) : txData);
    } catch (parseError) {
      console.error("Failed to parse/copy transaction data:", parseError);
      txDataCopy = txData; // Use as-is if parsing fails
    }
    
    // Log transaction structure to help debug
    console.log("Transaction structure:", {
      txid: txDataCopy?.txid || txDataCopy?.hash || "unknown",
      inputCount: txDataCopy?.vin?.length || 0,
      version: txDataCopy?.version,
      format: txDataCopy?.decoded_json ? "stored" : "direct"
    });
    
    // If txData includes a decoded_json property, use that instead
    if (txDataCopy?.decoded_json && typeof txDataCopy.decoded_json === 'string') {
      try {
        txDataCopy = JSON.parse(txDataCopy.decoded_json);
        console.log("Using parsed decoded_json data");
      } catch (jsonError) {
        console.error("Failed to parse decoded_json:", jsonError);
      }
    } else if (txDataCopy?.decoded_json && typeof txDataCopy.decoded_json === 'object') {
      txDataCopy = txDataCopy.decoded_json;
      console.log("Using decoded_json object data");
    }
    
    // Handle blockchain.info specific format
    if (txDataCopy?.inputs && Array.isArray(txDataCopy.inputs) && txDataCopy.out && Array.isArray(txDataCopy.out)) {
      console.log("Detected blockchain.info format, converting to standard format");
      txDataCopy = {
        txid: txDataCopy.hash,
        version: txDataCopy.ver,
        vin: txDataCopy.inputs.map((input: any) => ({
          txid: input.prev_out?.hash,
          vout: input.prev_out?.n,
          scriptSig: {
            hex: input.script
          },
          // Handle witness data properly according to blockchain.info format
          witness: input.witness,
          // Ensure witness data is available in a format compatible with our extraction code
          txinwitness: input.witness ? 
            (Array.isArray(input.witness) ? input.witness : [input.witness]) : 
            undefined
        })),
        vout: txDataCopy.out.map((output: any, index: number) => ({
          n: index,
          scriptPubKey: {
            hex: output.script
          },
          value: output.value / 100000000 // Convert satoshis to BTC
        }))
      };
    }
    
    // Enhanced check for witness data, supporting both direct witnesses and nested arrays
    const hasWitness = txDataCopy?.vin && 
      Array.isArray(txDataCopy.vin) && 
      txDataCopy.vin.some((input: any) => {
        // Direct txinwitness array
        if (input.txinwitness && Array.isArray(input.txinwitness) && input.txinwitness.length > 0) {
          return true;
        }
        
        // Witness can be array or string
        if (input.witness) {
          if (Array.isArray(input.witness) && input.witness.length > 0) {
            return true;
          }
          if (typeof input.witness === 'string' && input.witness.length > 0) {
            return true;
          }
        }
        
        // Some APIs use scriptWitness
        if (input.scriptWitness && Array.isArray(input.scriptWitness) && input.scriptWitness.length > 0) {
          return true;
        }
        
        return false;
      });
    
    console.log("Has witness data:", hasWitness || false);
    
    // Try SegWit extraction first if witness data is present
    if (hasWitness) {
      console.log("Found witness data, attempting SegWit extraction...");
      
      try {
        // Try each input with witness data
        for (const input of txDataCopy.vin) {
          let witnessData = null;
          
          // Check all possible witness field names
          if (input.txinwitness && Array.isArray(input.txinwitness) && input.txinwitness.length > 0) {
            witnessData = input.txinwitness;
          } else if (input.witness) {
            if (Array.isArray(input.witness)) {
              witnessData = input.witness;
            } else if (typeof input.witness === 'string' && input.witness.length > 0) {
              // Try to parse the witness string (could be hex or JSON)
              try {
                const parsed = JSON.parse(input.witness);
                witnessData = Array.isArray(parsed) ? parsed : [input.witness];
              } catch (e) {
                // Not parseable as JSON, treat as a string
                witnessData = [input.witness];
              }
            }
          } else if (input.scriptWitness && Array.isArray(input.scriptWitness)) {
            witnessData = input.scriptWitness;
          }
          
          if (witnessData) {
            const segwitData = extractSegWitData(witnessData);
            if (segwitData) {
              console.log("SegWit extraction successful");
              return segwitData;
            }
          }
        }
        
        console.log("SegWit extraction failed despite finding witness data");
      } catch (segwitError) {
        console.error("Error in SegWit extraction:", segwitError);
      }
    }
    
    // Try P2PKH extraction next
    console.log("Attempting P2PKH data extraction...");
    try {
      if (txDataCopy?.vin && Array.isArray(txDataCopy.vin)) {
        for (const input of txDataCopy.vin) {
          // Check if this input has a scriptSig with hex data
          if (input.scriptSig && input.scriptSig.hex) {
            console.log("Found scriptSig.hex in first vin element");
            console.log("Extracted scriptSig hex:", input.scriptSig.hex.substring(0, 30) + "...");
            
            const p2pkhData = extractP2PKHData(input.scriptSig.hex);
            if (p2pkhData) {
              console.log("P2PKH extraction successful");
              return p2pkhData;
            }
          }
        }
      }
      
      console.log("P2PKH extraction failed, could not find valid scriptSig");
    } catch (p2pkhError) {
      console.error("Error in P2PKH extraction:", p2pkhError);
    }
    
    // Try raw hex extraction as a last resort
    console.log("P2PKH extraction failed, attempting raw hex extraction...");
    try {
      const hexData = extractHexData(txDataCopy);
      if (hexData) {
        console.log("Raw hex extraction successful");
        return hexData;
      }
    } catch (hexError) {
      console.error("Error in hex extraction:", hexError);
    }
    
    // If we get here, all extraction methods failed
    console.error("All extraction methods failed - could not extract cryptographic data");
    console.log("Transaction data structure:", 
      JSON.stringify(Object.keys(txDataCopy)).substring(0, 500));
    
    // Could not extract data from any known format
    throw new Error("Could not extract cryptographic data from transaction");
  } catch (error) {
    console.error("Error in cryptographic data extraction process:", error);
    throw error; // Rethrow so callers know extraction failed
  }
};

// Re-export extraction utilities
export { extractP2PKHData } from './p2pkh';
export { extractSegWitData } from './segwit';
export { extractHexData, bytesToHex, hexToBytes } from './hexUtils';
