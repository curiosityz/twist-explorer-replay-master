import { CryptographicPoint, Signature } from '@/types';
import { extractP2PKHData } from './p2pkhExtractor';
import { extractSegWitData } from './segwitExtractor';
import { decodeDERSignature } from '@/lib/crypto/signatureUtils';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoinLibsCheck';
import { isPointOnSecp256k1Curve, validatePublicKey } from '@/lib/crypto/publicKeyUtils';

/**
 * Extract signature and public key from transaction data
 * @param txData Transaction data from RPC
 * @returns Extracted cryptographic data or null
 */
export const extractCryptographicData = (txData: any) => {
  try {
    // First check if Bitcoin libraries are loaded
    const libCheck = checkBitcoinLibsLoaded();
    if (!libCheck.loaded) {
      console.error(`Bitcoin libraries not loaded: Missing ${libCheck.missing.join(', ')}`);
      throw new Error(`Bitcoin libraries not loaded: Missing ${libCheck.missing.join(', ')}`);
    }
    
    if (!txData) {
      console.log("No transaction data provided");
      return null;
    }
    
    if (!txData.vin || !Array.isArray(txData.vin) || txData.vin.length === 0) {
      console.log("No inputs found in transaction data");
      return null;
    }

    console.log(`Transaction has ${txData.vin.length} inputs`);
    console.log("Transaction structure:", JSON.stringify({
      version: txData.version,
      vinCount: txData.vin?.length,
      voutCount: txData.vout?.length,
      hasScriptSig: txData.vin[0]?.scriptSig !== undefined,
      hasWitness: txData.vin[0]?.txinwitness !== undefined
    }));
    
    // Try to extract signature and public key from each input
    for (let i = 0; i < txData.vin.length; i++) {
      const input = txData.vin[i];
      console.log(`Processing input ${i + 1}/${txData.vin.length}`);
      
      let result: { signature: Signature, publicKey: CryptographicPoint } | null = null;
      
      try {
        // Case 1: P2PKH input with scriptSig (legacy)
        if (input.scriptSig && input.scriptSig.hex) {
          console.log(`Input ${i + 1} has scriptSig: ${input.scriptSig.hex.substring(0, 20)}...`);
          result = extractP2PKHData(input.scriptSig.hex);
        } 
        // Case 2: P2WPKH or P2WSH with witness data (segwit)
        else if (input.txinwitness && Array.isArray(input.txinwitness) && input.txinwitness.length >= 2) {
          console.log(`Input ${i + 1} has witness data with ${input.txinwitness.length} items`);
          result = extractSegWitData(input.txinwitness);
        } else {
          console.log(`Input ${i + 1} has neither scriptSig nor witness data, or insufficient witness items`);
        }
        
        // If extraction succeeded, validate and return the result
        if (result) {
          console.log(`Successfully extracted cryptographic data from input ${i + 1}`);
          
          // Thorough validation of the extracted public key
          const validationResult = validatePublicKey(result.publicKey.x, result.publicKey.y);
          
          if (!validationResult.isOnCurve) {
            console.log(`Point is not on the main secp256k1 curve - this could be a twist curve vulnerability`);
            // This is actually interesting for our vulnerability analysis, so we return it
            result.publicKey.isOnCurve = false;
          } else {
            result.publicKey.isOnCurve = true;
            
            if (!validationResult.isValid) {
              console.warn(`Public key validation issue: ${validationResult.reason}`);
            } else {
              console.log("Public key successfully validated");
            }
          }
          
          // Validate signature format
          if (!/^[0-9a-fA-F]+$/.test(result.signature.r) || !/^[0-9a-fA-F]+$/.test(result.signature.s)) {
            console.warn("Signature contains invalid characters");
          }
          
          return result;
        }
      } catch (inputError) {
        console.error(`Error processing input ${i + 1}:`, inputError);
        // Continue to next input
      }
    }
    
    console.log("Failed to extract cryptographic data from any inputs");
    throw new Error("Could not extract cryptographic data from transaction");
  } catch (error) {
    console.error("Error extracting cryptographic data:", error);
    throw error;
  }
};

/**
 * Validate that the extracted public key points are valid hex values
 * @param publicKey The public key point to validate
 * @returns Boolean indicating if the points are valid
 */
function validateExtractedPoints(publicKey: CryptographicPoint): boolean {
  if (!publicKey) return false;
  
  // Check that x and y are valid hex strings
  const validHex = /^[0-9a-fA-F]+$/;
  if (!validHex.test(publicKey.x) || !validHex.test(publicKey.y)) {
    console.error("Invalid hex in public key coordinates");
    return false;
  }
  
  // Check reasonable length (32 bytes = 64 hex chars)
  if (publicKey.x.length > 80 || publicKey.y.length > 80 || 
      publicKey.x.length < 60 || publicKey.y.length < 60) {
    console.error("Public key coordinates have suspicious length:", 
                 publicKey.x.length, publicKey.y.length);
    return false;
  }
  
  return true;
}

/**
 * Re-export all extraction utilities
 */
export * from './p2pkhExtractor';
export * from './segwitExtractor';
export * from './hexUtils';
