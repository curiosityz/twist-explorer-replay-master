
/**
 * Parse P2PKH script signature to extract signature and public key
 */

import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoin-libs';
import { bytesToHex } from '../hexUtils';

/**
 * Parse a P2PKH scriptSig to extract signature and public key chunks
 * @param scriptSigHex Hex string of scriptSig
 * @returns Object containing signature chunk and public key chunk, or null if parsing failed
 */
export const parseP2PKHScript = (scriptSigHex: string) => {
  try {
    // Check if Bitcoin libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.error(`Bitcoin libraries required for P2PKH parsing not loaded: ${libsCheck.missing.join(', ')}`);
      return null;
    }
    
    // Remove any '0x' prefix if present
    const cleanHex = scriptSigHex.startsWith('0x') ? scriptSigHex.substring(2) : scriptSigHex;
    
    // For empty or invalid scripts
    if (!cleanHex || cleanHex.length < 10) {
      console.error("Invalid or empty scriptSig");
      return null;
    }
    
    console.log("Parsing P2PKH scriptSig:", cleanHex.substring(0, 32) + "...");
    
    // If the Bitcoin library is available, use it to parse the script
    if (window.Bitcoin && window.Bitcoin.Script) {
      try {
        // Convert hex to bytes
        const scriptBytes = window.Bitcoin.Util.hexToBytes(cleanHex);
        
        // Parse script with Bitcoin.Script
        const script = new window.Bitcoin.Script(scriptBytes);
        const chunks = script.chunks;
        
        if (chunks.length < 2) {
          console.error("Script has fewer than 2 chunks, not a valid P2PKH scriptSig");
          return null;
        }
        
        // Typically, the first chunk is the signature (with sighash) and the second is the public key
        const sigChunk = chunks[0] instanceof Uint8Array ? 
          bytesToHex(chunks[0]) : 
          (chunks[0].toString ? chunks[0].toString('hex') : null);
        
        const pubKeyChunk = chunks[1] instanceof Uint8Array ? 
          bytesToHex(chunks[1]) : 
          (chunks[1].toString ? chunks[1].toString('hex') : null);
        
        if (!sigChunk || !pubKeyChunk) {
          console.error("Failed to extract signature or public key chunks");
          return null;
        }
        
        return { sigChunk, pubKeyChunk };
      } catch (bitcoinLibError) {
        console.error("Error using Bitcoin library for script parsing:", bitcoinLibError);
        // Fall through to manual parsing
      }
    }
    
    // Fallback manual parsing
    return manuallyParseP2PKHScript(cleanHex);
    
  } catch (error) {
    console.error("Error parsing P2PKH script:", error);
    return null;
  }
};

/**
 * Manually parse P2PKH script without relying on Bitcoin libraries
 * @param scriptHex Hex string of scriptSig
 * @returns Object with signature and public key chunks or null
 */
const manuallyParseP2PKHScript = (scriptHex: string) => {
  try {
    // Convert hex string to bytes for easier parsing
    const bytes = [];
    for (let i = 0; i < scriptHex.length; i += 2) {
      bytes.push(parseInt(scriptHex.substring(i, i + 2), 16));
    }
    
    let position = 0;
    const chunks = [];
    
    // Read script bytes sequentially
    while (position < bytes.length) {
      const opcode = bytes[position];
      position++;
      
      // Handle various push data opcodes
      if (opcode > 0 && opcode <= 0x4b) {
        // Direct push opcodes (1-75 bytes)
        const length = opcode;
        if (position + length > bytes.length) {
          console.error("Script parsing error: push data exceeds script length");
          return null;
        }
        
        // Extract the push data
        const chunk = bytes.slice(position, position + length);
        // Convert array to Uint8Array
        chunks.push(bytesToHex(new Uint8Array(chunk)));
        position += length;
      } else if (opcode === 0x4c) {
        // OP_PUSHDATA1
        if (position >= bytes.length) {
          console.error("Script parsing error: OP_PUSHDATA1 with no length byte");
          return null;
        }
        
        const length = bytes[position];
        position++;
        
        if (position + length > bytes.length) {
          console.error("Script parsing error: OP_PUSHDATA1 data exceeds script length");
          return null;
        }
        
        const chunk = bytes.slice(position, position + length);
        // Convert array to Uint8Array
        chunks.push(bytesToHex(new Uint8Array(chunk)));
        position += length;
      } else if (opcode === 0x4d) {
        // OP_PUSHDATA2
        if (position + 1 >= bytes.length) {
          console.error("Script parsing error: OP_PUSHDATA2 with incomplete length bytes");
          return null;
        }
        
        const length = bytes[position] | (bytes[position + 1] << 8);
        position += 2;
        
        if (position + length > bytes.length) {
          console.error("Script parsing error: OP_PUSHDATA2 data exceeds script length");
          return null;
        }
        
        const chunk = bytes.slice(position, position + length);
        // Convert array to Uint8Array
        chunks.push(bytesToHex(new Uint8Array(chunk)));
        position += length;
      } else if (opcode === 0x4e) {
        // OP_PUSHDATA4
        if (position + 3 >= bytes.length) {
          console.error("Script parsing error: OP_PUSHDATA4 with incomplete length bytes");
          return null;
        }
        
        const length = bytes[position] | 
                      (bytes[position + 1] << 8) | 
                      (bytes[position + 2] << 16) | 
                      (bytes[position + 3] << 24);
        position += 4;
        
        if (position + length > bytes.length) {
          console.error("Script parsing error: OP_PUSHDATA4 data exceeds script length");
          return null;
        }
        
        const chunk = bytes.slice(position, position + length);
        // Convert array to Uint8Array
        chunks.push(bytesToHex(new Uint8Array(chunk)));
        position += length;
      } else {
        // Non-push opcodes (including OP_0) - not expected in standard P2PKH scriptSig
        console.warn(`Unexpected opcode ${opcode.toString(16)} in P2PKH scriptSig`);
        chunks.push(opcode.toString(16));
      }
    }
    
    // A standard P2PKH scriptSig should have exactly 2 data pushes
    if (chunks.length !== 2) {
      console.error(`Invalid P2PKH scriptSig: found ${chunks.length} chunks, expected 2`);
      return null;
    }
    
    // The first chunk is the signature, the second is the public key
    const sigChunk = chunks[0];
    const pubKeyChunk = chunks[1];
    
    // Validate signature format (should start with 0x30 for DER)
    if (!sigChunk.startsWith('30')) {
      console.error("Invalid signature format: does not start with 0x30 (DER)");
      return null;
    }
    
    // Validate public key format
    // Compressed public keys start with 02 or 03 and are 33 bytes (66 hex chars)
    // Uncompressed public keys start with 04 and are 65 bytes (130 hex chars)
    const isCompressedKey = pubKeyChunk.startsWith('02') || pubKeyChunk.startsWith('03');
    const isUncompressedKey = pubKeyChunk.startsWith('04');
    const isValidKeyLength = 
      (isCompressedKey && pubKeyChunk.length === 66) || 
      (isUncompressedKey && pubKeyChunk.length === 130);
      
    if (!isValidKeyLength) {
      console.error(`Invalid public key format or length: ${pubKeyChunk.substring(0, 4)}... (length: ${pubKeyChunk.length})`);
      return null;
    }
    
    return { sigChunk, pubKeyChunk };
  } catch (error) {
    console.error("Error in manual P2PKH script parsing:", error);
    return null;
  }
};
