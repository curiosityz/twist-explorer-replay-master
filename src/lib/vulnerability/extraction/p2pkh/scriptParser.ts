
/**
 * Parse P2PKH script signature to extract signature and public key
 */

import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoinLibsCheck';

/**
 * Parse a P2PKH scriptSig to extract signature and public key chunks
 * @param scriptSigHex Hex string of scriptSig
 * @returns Object containing signature chunk and public key chunk, or null if parsing failed
 */
export const parseP2PKHScript = (scriptSigHex: string) => {
  try {
    // Check if Bitcoin libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.error(`Bitcoin libraries required for P2PKH parsing not loaded: ${libsCheck.missing.join(', ')}`);
      return null;
    }
    
    // Remove any '0x' prefix if present
    const cleanHex = scriptSigHex.startsWith('0x') ? scriptSigHex.substring(2) : scriptSigHex;
    
    // For empty or invalid scripts
    if (!cleanHex || cleanHex.length < 10) {
      console.error("Invalid or empty scriptSig");
      return null;
    }
    
    console.log("Parsing P2PKH scriptSig:", cleanHex.substring(0, 32) + "...");
    
    // If the Bitcoin library is available, use it to parse the script
    if (window.Bitcoin && window.Bitcoin.Script) {
      try {
        // Convert hex to bytes
        const scriptBytes = window.Bitcoin.Util.hexToBytes(cleanHex);
        
        // Parse script with Bitcoin.Script
        const script = new window.Bitcoin.Script(scriptBytes);
        const chunks = script.chunks;
        
        if (chunks.length < 2) {
          console.error("Script has fewer than 2 chunks, not a valid P2PKH scriptSig");
          return null;
        }
        
        // Typically, the first chunk is the signature (with sighash) and the second is the public key
        const sigChunk = chunks[0] instanceof Uint8Array ? 
          window.Bitcoin.Util.bytesToHex(chunks[0]) : 
          (chunks[0].toString ? chunks[0].toString('hex') : null);
        
        const pubKeyChunk = chunks[1] instanceof Uint8Array ? 
          window.Bitcoin.Util.bytesToHex(chunks[1]) : 
          (chunks[1].toString ? chunks[1].toString('hex') : null);
        
        if (!sigChunk || !pubKeyChunk) {
          console.error("Failed to extract signature or public key chunks");
          return null;
        }
        
        return { sigChunk, pubKeyChunk };
      } catch (bitcoinLibError) {
        console.error("Error using Bitcoin library for script parsing:", bitcoinLibError);
        // Fall through to manual parsing
      }
    }
    
    // Fallback manual parsing
    return manuallyParseP2PKHScript(cleanHex);
    
  } catch (error) {
    console.error("Error parsing P2PKH script:", error);
    return null;
  }
};

/**
 * Manually parse P2PKH script without relying on Bitcoin libraries
 * @param scriptHex Hex string of scriptSig
 * @returns Object with signature and public key chunks or null
 */
const manuallyParseP2PKHScript = (scriptHex: string) => {
  try {
    // Convert hex string to bytes for easier parsing
    const bytes = [];
    for (let i = 0; i < scriptHex.length; i += 2) {
      bytes.push(parseInt(scriptHex.substring(i, i + 2), 16));
    }
    
    // Find signature chunk - typically starts with 0x30 (DER format)
    let sigStart = -1;
    let sigLen = 0;
    
    for (let i = 0; i < bytes.length; i++) {
      if (bytes[i] === 0x30 && i < bytes.length - 2) {
        // DER signature starts with 0x30 followed by length
        sigLen = bytes[i + 1] + 2; // +2 for the initial 0x30 and length byte
        sigStart = i - 1; // Going back 1 byte to include the push opcode
        break;
      }
    }
    
    if (sigStart === -1 || sigLen === 0) {
      console.error("Could not find signature in script");
      return null;
    }
    
    // The signature should be preceded by its length
    const sigPushOpcode = bytes[sigStart];
    
    // Find public key chunk - typically 33 bytes (compressed) or 65 bytes (uncompressed)
    let pubKeyStart = sigStart + sigLen + 2; // +2 for the push opcode and signature length
    
    if (pubKeyStart >= bytes.length - 1) {
      console.error("Script doesn't contain public key");
      return null;
    }
    
    // Check for public key opcode (0x21 for compressed, 0x41 for uncompressed)
    const pubKeyLen = bytes[pubKeyStart];
    pubKeyStart++; // Move past the length byte
    
    if (pubKeyLen !== 0x21 && pubKeyLen !== 0x41) {
      console.error("Invalid public key length in script");
      return null;
    }
    
    // Extract signature chunk (including the sighash type byte)
    const sigEndPos = sigStart + sigLen + 2; // +2 for push opcode and length
    const sigChunk = scriptHex.substring((sigStart + 1) * 2, sigEndPos * 2);
    
    // Extract public key chunk
    const pubKeyEndPos = pubKeyStart + pubKeyLen;
    const pubKeyChunk = scriptHex.substring(pubKeyStart * 2, pubKeyEndPos * 2);
    
    return { sigChunk, pubKeyChunk };
  } catch (error) {
    console.error("Error in manual P2PKH script parsing:", error);
    return null;
  }
};
