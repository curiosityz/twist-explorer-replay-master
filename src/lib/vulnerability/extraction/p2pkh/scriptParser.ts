
/**
 * Parser for P2PKH script data
 */
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoin-libs';

/**
 * Parse P2PKH script into components
 * @param scriptSigHex Hex string of scriptSig
 * @returns The parsed script chunks or null if parsing fails
 */
export const parseP2PKHScript = (scriptSigHex: string): { sigChunk: any; pubKeyChunk: any } | null => {
  try {
    // Check if libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
      throw new Error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
    }
    
    // Safety check for scriptSigHex
    if (!scriptSigHex || scriptSigHex.length < 10) {
      console.error("Invalid scriptSig hex data");
      return null;
    }
    
    let scriptSig;
    try {
      // Use bitcoinjs to parse the script
      scriptSig = window.Bitcoin.Script.fromHex(scriptSigHex);
    } catch (scriptError) {
      console.error("Failed to parse scriptSig hex:", scriptError);
      return null;
    }
    
    if (!scriptSig || !scriptSig.chunks || scriptSig.chunks.length < 2) {
      console.log("Invalid script structure, chunks:", scriptSig?.chunks?.length || 0);
      return null;
    }
    
    // P2PKH typically has 2 chunks: signature and public key
    const sigChunk = scriptSig.chunks[0];
    const pubKeyChunk = scriptSig.chunks[1];
    
    if (!sigChunk || !pubKeyChunk) {
      console.log("Missing signature or public key chunk");
      return null;
    }
    
    console.log("Found potential scriptSig chunks");
    return { sigChunk, pubKeyChunk };
    
  } catch (error) {
    console.error("Error parsing P2PKH script:", error);
    return null;
  }
};
