
/**
 * Utilities for extracting signatures from P2PKH inputs
 */

import { Signature } from '@/types';
import { bytesToHex } from '../hexUtils';

/**
 * Extract signature from signature bytes using Bitcoin's ECDSA parser
 * @param sigBytes Raw signature bytes
 * @returns Parsed signature or null if parsing fails
 */
export const extractSignatureFromBitcoinECDSA = (sigBytes: any): Signature | null => {
  try {
    // Use bitcoin library for DER signature parsing
    const sigData = window.Bitcoin.ECDSA.parseSigCompact(sigBytes);
    
    const r = sigData.r.toString(16).padStart(64, '0');
    const s = sigData.s.toString(16).padStart(64, '0');
    const sighashType = sigBytes[sigBytes.length - 1];
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    const signature: Signature = {
      r: r,
      s: s,
      sighash: sighashHex
    };
    
    console.log("Extracted signature from DER:", 
      "r:", signature.r.substring(0, 10) + "...", 
      "s:", signature.s.substring(0, 10) + "...");
      
    return signature;
  } catch (error) {
    console.error("Error using Bitcoin ECDSA parser:", error);
    return null;
  }
};

/**
 * Extract signature using manual DER parsing as fallback
 * @param sigBytes Raw signature bytes
 * @returns Parsed signature or null if parsing fails
 */
export const extractSignatureManually = (sigBytes: any): Signature | null => {
  try {
    // Manual DER parsing as fallback
    let pos = 1; // Skip '30'
    const totalLen = sigBytes[pos];
    pos++;
    
    if (sigBytes[pos] !== 0x02) {
      throw new Error('Invalid DER signature: missing first integer marker');
    }
    pos++;
    
    const rLen = sigBytes[pos];
    pos++;
    const rValue = sigBytes.slice(pos, pos + rLen);
    pos += rLen;
    
    if (sigBytes[pos] !== 0x02) {
      throw new Error('Invalid DER signature: missing second integer marker');
    }
    pos++;
    
    const sLen = sigBytes[pos];
    pos++;
    const sValue = sigBytes.slice(pos, pos + sLen);
    
    // Get sighash byte (last byte)
    const sighashType = sigBytes[sigBytes.length - 1];
    
    // Convert to hex
    const rHex = bytesToHex(rValue).padStart(64, '0');
    const sHex = bytesToHex(sValue).padStart(64, '0');
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    const signature: Signature = {
      r: rHex,
      s: sHex,
      sighash: sighashHex
    };
    
    console.log("Extracted signature using fallback method:", 
      "r:", signature.r.substring(0, 10) + "...", 
      "s:", signature.s.substring(0, 10) + "...");
      
    return signature;
    
  } catch (error) {
    console.error("Error in manual signature parsing:", error);
    return null;
  }
};
