
/**
 * Utilities for extracting public keys from P2PKH inputs
 */

import { CryptographicPoint } from '@/types';
import { bytesToHex } from '../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';
import { isPointOnSecp256k1Curve } from '@/lib/crypto/publicKeyUtils/isPointOnCurve';

/**
 * Extract public key from public key bytes
 * @param pubKeyBytes Raw public key bytes
 * @returns Extracted public key point or null if extraction fails
 */
export const extractPublicKeyFromBytes = (pubKeyBytes: any): CryptographicPoint | null => {
  try {
    if (!pubKeyBytes || pubKeyBytes.length === 0) {
      console.log("Empty public key bytes");
      return null;
    }
    
    // Handle different public key formats using bitcoinjs
    if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
      // Uncompressed key (04 + x + y)
      const xBytes = pubKeyBytes.slice(1, 33);
      const yBytes = pubKeyBytes.slice(33, 65);
      
      const xHex = bytesToHex(xBytes);
      const yHex = bytesToHex(yBytes);
      
      // Check if the point is on the curve
      const isOnCurve = isPointOnSecp256k1Curve(xHex, yHex);
      
      const publicKey: CryptographicPoint = {
        x: xHex,
        y: yHex,
        isOnCurve
      };
      
      console.log("Extracted uncompressed public key:", 
        "x:", publicKey.x.substring(0, 10) + "...", 
        "y:", publicKey.y.substring(0, 10) + "...",
        "isOnCurve:", publicKey.isOnCurve);
        
      return publicKey;
    }
    else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
      // Compressed key (02/03 + x)
      try {
        const pubKeyHex = bytesToHex(pubKeyBytes);
        
        // Use secp256k1 library directly to decompress the key
        if (window.secp256k1) {
          try {
            // Fixed: Remove the second parameter from publicKeyConvert
            const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
            
            // Extract x and y coordinates (format: 04 | x | y)
            const xBytes = decompressed.slice(1, 33);
            const yBytes = decompressed.slice(33, 65);
            
            const xHex = bytesToHex(xBytes);
            const yHex = bytesToHex(yBytes);
            
            // Check if the point is on the curve
            const isOnCurve = isPointOnSecp256k1Curve(xHex, yHex);
            
            const publicKey: CryptographicPoint = {
              x: xHex,
              y: yHex,
              isOnCurve
            };
            
            return publicKey;
          } catch (secp256k1Error) {
            console.log("Failed to decompress using secp256k1 methods");
            // Fall back to utility function
          }
        }
        
        // Fall back to our utility function if secp256k1 isn't available or failed
        console.log("Decompressing public key with utility function");
        const decomp = decompressPublicKey(pubKeyHex);
        
        if (!decomp) {
          console.error("Failed to decompress public key");
          return null;
        }
        
        const publicKey: CryptographicPoint = {
          x: decomp.x,
          y: decomp.y,
          isOnCurve: decomp.isOnCurve
        };
        
        return publicKey;
      } catch (decompError) {
        console.error("Error decompressing public key:", decompError);
        return null;
      }
    } else {
      console.log("Invalid public key format. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
      return null;
    }
  } catch (error) {
    console.error("Error extracting public key:", error);
    return null;
  }
};
