
/**
 * Utilities for extracting public keys from P2PKH inputs
 */

import { CryptographicPoint } from '@/types';
import { bytesToHex } from '../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';

/**
 * Extract public key from public key bytes
 * @param pubKeyBytes Raw public key bytes
 * @returns Extracted public key point or null if extraction fails
 */
export const extractPublicKeyFromBytes = (pubKeyBytes: any): CryptographicPoint | null => {
  try {
    if (!pubKeyBytes || pubKeyBytes.length === 0) {
      console.log("Empty public key bytes");
      return null;
    }
    
    // Handle different public key formats using bitcoinjs
    if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
      // Uncompressed key (04 + x + y)
      const xBytes = pubKeyBytes.slice(1, 33);
      const yBytes = pubKeyBytes.slice(33, 65);
      
      const xHex = bytesToHex(xBytes);
      const yHex = bytesToHex(yBytes);
      
      const publicKey: CryptographicPoint = {
        x: xHex,
        y: yHex,
        isOnCurve: true // We'll validate this later
      };
      
      console.log("Extracted uncompressed public key:", 
        "x:", publicKey.x.substring(0, 10) + "...", 
        "y:", publicKey.y.substring(0, 10) + "...");
        
      return publicKey;
    }
    else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
      // Compressed key (02/03 + x)
      try {
        const pubKeyHex = bytesToHex(pubKeyBytes);
        
        // Use secp256k1 library directly to decompress the key
        if (window.secp256k1) {
          // Fix: Remove the second parameter from publicKeyConvert
          const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
          
          // Extract x and y coordinates (format: 04 | x | y)
          const xBytes = decompressed.slice(1, 33);
          const yBytes = decompressed.slice(33, 65);
          
          const xHex = bytesToHex(xBytes);
          const yHex = bytesToHex(yBytes);
          
          const publicKey: CryptographicPoint = {
            x: xHex,
            y: yHex,
            isOnCurve: true
          };
          
          return publicKey;
        } else {
          // Fall back to our utility function if secp256k1 isn't available
          const decomp = decompressPublicKey(pubKeyHex);
          
          const publicKey: CryptographicPoint = {
            x: decomp.x,
            y: decomp.y,
            isOnCurve: decomp.isOnCurve
          };
          
          return publicKey;
        }
      } catch (decompError) {
        console.error("Error decompressing public key:", decompError);
        return null;
      }
    } else {
      console.log("Invalid public key format. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
      return null;
    }
  } catch (error) {
    console.error("Error extracting public key:", error);
    return null;
  }
};
