
/**
 * Main export file for P2PKH data extraction utilities
 */

import { parseP2PKHScript } from './scriptParser';
import { CryptographicPoint, Signature } from '@/types';
import { bytesToHex } from '../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoin-libs';
import { extractSignatureFromBitcoinECDSA, extractSignatureManually } from './signatureExtractor';
import { extractPublicKeyFromBytes } from './publicKeyExtractor';

// Export other functionality from P2PKH submodule
export { parseP2PKHScript };

/**
 * Extract cryptographic data from P2PKH transaction input
 * @param txInput Transaction input data
 * @returns Object with signature and public key or null
 */
export const extractP2PKHData = (txInput: any) => {
  try {
    // Check if libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
      console.warn("Will attempt extraction with fallback methods");
    }
    
    // Safety check for txInput
    if (!txInput) {
      console.error("Invalid transaction input data");
      return null;
    }
    
    // Extract scriptSig from transaction input
    let scriptSigHex;
    
    // Handle different transaction input formats
    if (typeof txInput === 'string') {
      // Direct scriptSig hex
      scriptSigHex = txInput;
      console.log("Using direct hex scriptSig input");
    } else if (txInput.scriptSig && typeof txInput.scriptSig.hex === 'string') {
      // Standard blockchain API format
      scriptSigHex = txInput.scriptSig.hex;
      console.log("Found scriptSig.hex in transaction input");
    } else if (txInput.vin && Array.isArray(txInput.vin) && txInput.vin.length > 0) {
      // Transaction with vin array - use first input
      const firstInput = txInput.vin[0];
      if (firstInput && firstInput.scriptSig && typeof firstInput.scriptSig.hex === 'string') {
        scriptSigHex = firstInput.scriptSig.hex;
        console.log("Found scriptSig.hex in first vin element");
      } else {
        console.log("No scriptSig.hex in first vin, checking alternatives", firstInput);
        
        // Try additional known formats from different blockchain APIs
        if (firstInput && firstInput.script) {
          scriptSigHex = typeof firstInput.script === 'string' ? firstInput.script : null;
          console.log("Using firstInput.script as fallback");
        } else if (txInput.inputs && Array.isArray(txInput.inputs) && txInput.inputs.length > 0) {
          const input = txInput.inputs[0];
          if (input && input.script) {
            scriptSigHex = typeof input.script === 'string' ? input.script : null;
            console.log("Using txInput.inputs[0].script as fallback");
          }
        } else if (txInput.tx && txInput.tx.vin && Array.isArray(txInput.tx.vin) && txInput.tx.vin.length > 0) {
          const txVin = txInput.tx.vin[0];
          if (txVin && txVin.scriptSig && typeof txVin.scriptSig.hex === 'string') {
            scriptSigHex = txVin.scriptSig.hex;
            console.log("Using txInput.tx.vin[0].scriptSig.hex as fallback");
          }
        }
      }
    }
    
    if (!scriptSigHex) {
      console.error("Could not find scriptSig hex in transaction input");
      // Log the transaction input structure to help debugging
      console.log("Transaction input structure:", JSON.stringify(txInput, null, 2).substring(0, 500) + "...");
      return null;
    }
    
    console.log("Extracted scriptSig hex:", scriptSigHex.substring(0, 32) + "...");
    
    // Parse the scriptSig to extract signature and public key chunks
    const parsedScript = parseP2PKHScript(scriptSigHex);
    if (!parsedScript) {
      console.error("Failed to parse P2PKH script");
      return null;
    }
    
    const { sigChunk, pubKeyChunk } = parsedScript;
    console.log("Successfully parsed script, found signature and public key chunks");
    
    // Convert hex chunks to bytes for further processing
    const sigBytes = new Uint8Array(
      sigChunk.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16))
    );
    
    const pubKeyBytes = new Uint8Array(
      pubKeyChunk.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16))
    );
    
    // Process signature chunk
    let signature: Signature | null = null;
    
    // First try Bitcoin ECDSA parser if available
    if (window.Bitcoin && window.Bitcoin.ECDSA) {
      signature = extractSignatureFromBitcoinECDSA(sigBytes);
    }
    
    // Fall back to manual parsing if needed
    if (!signature) {
      signature = extractSignatureManually(sigBytes);
    }
    
    if (!signature) {
      console.error("Failed to extract valid signature from chunk");
      return null;
    }
    
    // Process public key chunk
    const publicKey = extractPublicKeyFromBytes(pubKeyBytes);
    if (!publicKey) {
      console.error("Failed to extract valid public key from chunk");
      return null;
    }
    
    console.log("Successfully extracted P2PKH data:", 
      "signature r:", signature.r.substring(0, 8) + "...", 
      "public key x:", publicKey.x.substring(0, 8) + "...");
    
    return { signature, publicKey };
  } catch (error) {
    console.error("Error extracting P2PKH data:", error);
    return null;
  }
};

export * from './publicKeyExtractor';
export * from './signatureExtractor';
