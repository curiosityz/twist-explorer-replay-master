
/**
 * Main export for P2PKH extraction functionality
 */

import { CryptographicPoint, Signature } from '@/types';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoinLibsCheck';
import { parseP2PKHScript } from './scriptParser';
import { extractSignatureFromBitcoinECDSA, extractSignatureManually } from './signatureExtractor';
import { extractPublicKeyFromBytes } from './publicKeyExtractor';

/**
 * Extract cryptographic data from P2PKH input
 * @param scriptSigHex Hex string of scriptSig
 * @returns Extracted signature and public key or null
 */
export const extractP2PKHData = (txData: any): { signature: Signature, publicKey: CryptographicPoint } | null => {
  try {
    // Check if libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.warn(`Bitcoin libraries not fully loaded: Missing ${libsCheck.missing.join(', ')}. Using fallback methods.`);
      // Continue with fallback methods instead of returning null immediately
    }
    
    // Find and extract scriptSig from transaction data
    let scriptSigHex = findScriptSigInTransaction(txData);
    
    if (!scriptSigHex) {
      console.error("No valid scriptSig found in transaction data");
      return null;
    }
    
    console.log("Found scriptSig:", scriptSigHex.substring(0, 32) + "...");
    
    // Parse the script to get chunks
    const parsedScript = parseP2PKHScript(scriptSigHex);
    if (!parsedScript) {
      console.error("Failed to parse P2PKH script");
      return null;
    }
    
    const { sigChunk, pubKeyChunk } = parsedScript;
    console.log("Successfully extracted signature and public key chunks");
    console.log("- Signature chunk:", sigChunk.substring(0, 32) + "...");
    console.log("- Public key chunk:", pubKeyChunk);
    
    // Extract signature
    let signature: Signature | null = extractSignatureFromBitcoinECDSA(sigChunk);
    
    // Try fallback if primary extraction failed
    if (!signature) {
      console.log("Primary signature extraction failed, trying manual extraction...");
      signature = extractSignatureManually(sigChunk);
      if (!signature) {
        console.error("Failed to extract signature using all available methods");
        return null;
      }
    }
    
    // Extract public key
    const publicKey = extractPublicKeyFromBytes(pubKeyChunk);
    if (!publicKey) {
      console.error("Failed to extract public key");
      return null;
    }
    
    console.log("Successfully extracted cryptographic data from P2PKH input");
    return { signature, publicKey };
  } catch (error) {
    console.error("Error extracting P2PKH data:", error);
    return null;
  }
};

/**
 * Find scriptSig in transaction data from various blockchain API formats
 * @param txData Transaction data from blockchain API
 * @returns scriptSig hex string or null if not found
 */
function findScriptSigInTransaction(txData: any): string | null {
  try {
    // Handle null or undefined input
    if (!txData) {
      console.error("Transaction data is null or undefined");
      return null;
    }
    
    console.log("Searching for scriptSig in transaction data...");
    
    // Case 1: Direct access to scriptSig.hex (most common)
    if (txData.vin && Array.isArray(txData.vin) && txData.vin.length > 0) {
      // Try all inputs until we find one with a scriptSig
      for (const input of txData.vin) {
        if (input.scriptSig && typeof input.scriptSig.hex === 'string' && input.scriptSig.hex.length > 0) {
          return input.scriptSig.hex;
        }
      }
    }
    
    // Case 2: Transaction hex string
    if (typeof txData === 'string' && txData.length > 20 && /^[0-9a-fA-F]+$/.test(txData)) {
      return txData; // The entire string could be the scriptSig or raw transaction
    }
    
    // Case 3: Raw hex in transaction object
    if (typeof txData.hex === 'string' && txData.hex.length > 20) {
      // This is a raw transaction hex, we need to parse it
      // For now, just return it for manual parsing
      return txData.hex;
    }
    
    // Case 4: Input scripts in different format
    if (txData.inputs && Array.isArray(txData.inputs)) {
      for (const input of txData.inputs) {
        if (input.script && typeof input.script === 'string' && input.script.length > 0) {
          return input.script;
        }
      }
    }
    
    // Case 5: If txData is directly the decoded_json as a string
    if (typeof txData === 'string') {
      try {
        const parsed = JSON.parse(txData);
        return findScriptSigInTransaction(parsed); // Recursive call with parsed object
      } catch (e) {
        // Not a JSON string
      }
    }
    
    // Case 6: Check if we need to parse decoded_json
    if (txData.decoded_json) {
      const decodedData = typeof txData.decoded_json === 'string' 
        ? JSON.parse(txData.decoded_json) 
        : txData.decoded_json;
      
      return findScriptSigInTransaction(decodedData); // Recursive call with decoded data
    }
    
    console.error("Could not find scriptSig in transaction data");
    console.log("Transaction data structure:", Object.keys(txData));
    return null;
    
  } catch (error) {
    console.error("Error finding scriptSig in transaction:", error);
    return null;
  }
}
