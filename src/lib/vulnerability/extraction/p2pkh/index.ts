
/**
 * Main export for P2PKH extraction functionality
 */

import { CryptographicPoint, Signature } from '@/types';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoin-libs/check-status';
import { parseP2PKHScript } from './scriptParser';
import { extractSignatureFromBitcoinECDSA, extractSignatureManually } from './signatureExtractor';
import { extractPublicKeyFromBytes } from './publicKeyExtractor';

/**
 * Extract cryptographic data from P2PKH input
 * @param scriptSigHex Hex string of scriptSig
 * @returns Extracted signature and public key or null
 */
export const extractP2PKHData = (scriptSigHex: string): { signature: Signature, publicKey: CryptographicPoint } | null => {
  try {
    // Check if libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      throw new Error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
    }
    
    // Parse the script to get chunks
    const parsedScript = parseP2PKHScript(scriptSigHex);
    if (!parsedScript) {
      return null;
    }
    
    const { sigChunk, pubKeyChunk } = parsedScript;
    
    // Extract signature
    let signature: Signature | null = extractSignatureFromBitcoinECDSA(sigChunk);
    
    // Try fallback if primary extraction failed
    if (!signature) {
      signature = extractSignatureManually(sigChunk);
      if (!signature) {
        console.error("Failed to extract signature using all available methods");
        return null;
      }
    }
    
    // Extract public key
    const publicKey = extractPublicKeyFromBytes(pubKeyChunk);
    if (!publicKey) {
      console.error("Failed to extract public key");
      return null;
    }
    
    return { signature, publicKey };
  } catch (error) {
    console.error("Error extracting P2PKH data:", error);
    return null;
  }
};
