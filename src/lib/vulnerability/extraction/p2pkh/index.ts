/**
 * Main export file for P2PKH data extraction utilities
 */

import { parseP2PKHScript } from './scriptParser';
import { CryptographicPoint, Signature } from '@/types';
import { bytesToHex } from '../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoin-libs';

// Export other functionality from P2PKH submodule
export { parseP2PKHScript };

/**
 * Extract cryptographic data from P2PKH transaction input
 * @param txInput Transaction input data
 * @returns Object with signature and public key or null
 */
export const extractP2PKHData = (txInput: any) => {
  try {
    // Check if libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
      throw new Error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
    }
    
    // Safety check for txInput
    if (!txInput) {
      console.error("Invalid transaction input data");
      return null;
    }
    
    // Extract scriptSig from transaction input
    let scriptSigHex;
    
    // Handle different transaction input formats
    if (typeof txInput === 'string') {
      // Direct scriptSig hex
      scriptSigHex = txInput;
    } else if (txInput.scriptSig && typeof txInput.scriptSig.hex === 'string') {
      // Standard blockchain API format
      scriptSigHex = txInput.scriptSig.hex;
    } else if (txInput.vin && Array.isArray(txInput.vin) && txInput.vin.length > 0) {
      // Transaction with vin array - use first input
      const firstInput = txInput.vin[0];
      if (firstInput.scriptSig && typeof firstInput.scriptSig.hex === 'string') {
        scriptSigHex = firstInput.scriptSig.hex;
      }
    }
    
    if (!scriptSigHex) {
      console.error("Could not find scriptSig hex in transaction input");
      return null;
    }
    
    // Parse the scriptSig to extract signature and public key chunks
    const parsedScript = parseP2PKHScript(scriptSigHex);
    if (!parsedScript) {
      console.error("Failed to parse P2PKH script");
      return null;
    }
    
    const { sigChunk, pubKeyChunk } = parsedScript;
    
    // Process signature chunk
    const signature = extractSignatureFromChunk(sigChunk);
    if (!signature) {
      console.error("Failed to extract valid signature from chunk");
      return null;
    }
    
    // Process public key chunk
    const publicKey = extractPublicKeyFromChunk(pubKeyChunk);
    if (!publicKey) {
      console.error("Failed to extract valid public key from chunk");
      return null;
    }
    
    return { signature, publicKey };
  } catch (error) {
    console.error("Error extracting P2PKH data:", error);
    return null;
  }
};

/**
 * Extract signature from DER-encoded signature chunk
 * @param sigChunk Hex string of signature chunk
 * @returns Signature object or null
 */
const extractSignatureFromChunk = (sigChunk: string): Signature | null => {
  try {
    // Convert hex to bytes
    const sigBytes = new Uint8Array(
      sigChunk.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16))
    );
    
    // Use bitcoin library for DER signature parsing if available
    if (window.Bitcoin && window.Bitcoin.ECDSA) {
      try {
        // Extract signature using bitcoinjs's ECDSA parsing
        const sigData = window.Bitcoin.ECDSA.parseSigCompact(sigBytes);
        
        const r = sigData.r.toString(16).padStart(64, '0');
        const s = sigData.s.toString(16).padStart(64, '0');
        const sighashType = sigBytes[sigBytes.length - 1];
        const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
        
        return {
          r: r,
          s: s,
          sighash: sighashHex
        };
      } catch (parseError) {
        console.error("Error using Bitcoin ECDSA to parse signature:", parseError);
        // Fall through to manual parsing
      }
    }
    
    // Manual DER parsing as fallback
    let pos = 1; // Skip '30'
    const totalLen = sigBytes[pos];
    pos++;
    
    if (sigBytes[pos] !== 0x02) {
      throw new Error('Invalid DER signature: missing first integer marker');
    }
    pos++;
    
    const rLen = sigBytes[pos];
    pos++;
    const rValue = sigBytes.slice(pos, pos + rLen);
    pos += rLen;
    
    if (sigBytes[pos] !== 0x02) {
      throw new Error('Invalid DER signature: missing second integer marker');
    }
    pos++;
    
    const sLen = sigBytes[pos];
    pos++;
    const sValue = sigBytes.slice(pos, pos + sLen);
    
    // Get sighash byte (last byte)
    const sighashType = sigBytes[sigBytes.length - 1];
    
    // Convert to hex
    const rHex = bytesToHex(rValue).padStart(64, '0');
    const sHex = bytesToHex(sValue).padStart(64, '0');
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    return {
      r: rHex,
      s: sHex,
      sighash: sighashHex
    };
  } catch (error) {
    console.error("Error extracting signature from chunk:", error);
    return null;
  }
};

/**
 * Extract public key from public key chunk
 * @param pubKeyChunk Hex string of public key chunk
 * @returns CryptographicPoint object or null
 */
const extractPublicKeyFromChunk = (pubKeyChunk: string): CryptographicPoint | null => {
  try {
    // Convert hex to bytes
    const pubKeyBytes = new Uint8Array(
      pubKeyChunk.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16))
    );
    
    // Handle different public key formats
    if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
      // Uncompressed key (04 + x + y)
      const xBytes = pubKeyBytes.slice(1, 33);
      const yBytes = pubKeyBytes.slice(33, 65);
      
      const xHex = bytesToHex(xBytes);
      const yHex = bytesToHex(yBytes);
      
      return {
        x: xHex,
        y: yHex,
        isOnCurve: true // We'll validate this later
      };
    }
    else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
      // Compressed key (02/03 + x)
      try {
        // Use secp256k1 library directly to decompress the key if available
        if (window.secp256k1) {
          const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
          
          // Extract x and y coordinates (format: 04 | x | y)
          const xBytes = decompressed.slice(1, 33);
          const yBytes = decompressed.slice(33, 65);
          
          const xHex = bytesToHex(xBytes);
          const yHex = bytesToHex(yBytes);
          
          return {
            x: xHex,
            y: yHex,
            isOnCurve: true
          };
        } else {
          // Fall back to our utility function if secp256k1 isn't available
          const decomp = decompressPublicKey(pubKeyChunk);
          
          return {
            x: decomp.x,
            y: decomp.y,
            isOnCurve: decomp.isOnCurve
          };
        }
      } catch (decompError) {
        console.error("Error decompressing public key:", decompError);
        return null;
      }
    } else {
      console.log("Invalid public key format. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
      return null;
    }
  } catch (error) {
    console.error("Error extracting public key from chunk:", error);
    return null;
  }
};

export * from './publicKeyExtractor';
export * from './signatureExtractor';
