
import { CryptographicPoint, Signature } from '@/types';
import { bytesToHex } from './hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoinLibsCheck';

/**
 * Extract cryptographic data from P2PKH input
 * @param scriptSigHex Hex string of scriptSig
 * @returns Extracted signature and public key or null
 */
export const extractP2PKHData = (scriptSigHex: string): { signature: Signature, publicKey: CryptographicPoint } | null => {
  try {
    // Check if libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
      throw new Error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
    }
    
    // Safety check for scriptSigHex
    if (!scriptSigHex || scriptSigHex.length < 10) {
      console.error("Invalid scriptSig hex data");
      return null;
    }
    
    let scriptSig;
    try {
      // Use bitcoinjs to parse the script
      scriptSig = window.Bitcoin.Script.fromHex(scriptSigHex);
    } catch (scriptError) {
      console.error("Failed to parse scriptSig hex:", scriptError);
      return null;
    }
    
    if (!scriptSig || !scriptSig.chunks || scriptSig.chunks.length < 2) {
      console.log("Invalid script structure, chunks:", scriptSig?.chunks?.length || 0);
      return null;
    }
    
    // P2PKH typically has 2 chunks: signature and public key
    const sigChunk = scriptSig.chunks[0];
    const pubKeyChunk = scriptSig.chunks[1];
    
    if (!sigChunk || !pubKeyChunk) {
      console.log("Missing signature or public key chunk");
      return null;
    }
    
    console.log("Found potential scriptSig chunks");
    
    // Extract signature (DER format with sighash byte at the end)
    const sigBytes = sigChunk;
    if (!sigBytes || sigBytes.length === 0) {
      console.log("Empty signature bytes");
      return null;
    }
    
    // Use bitcoin library for DER signature parsing
    try {
      // Extract signature using bitcoinjs's ECDSA parsing
      const sigData = window.Bitcoin.ECDSA.parseSigCompact(sigBytes);
      
      const r = sigData.r.toString(16).padStart(64, '0');
      const s = sigData.s.toString(16).padStart(64, '0');
      const sighashType = sigBytes[sigBytes.length - 1];
      const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
      
      const signature: Signature = {
        r: r,
        s: s,
        sighash: sighashHex
      };
      
      console.log("Extracted signature from DER:", 
        "r:", signature.r.substring(0, 10) + "...", 
        "s:", signature.s.substring(0, 10) + "...");
      
      // Extract public key
      const pubKeyBytes = pubKeyChunk;
      if (!pubKeyBytes || pubKeyBytes.length === 0) {
        console.log("Empty public key bytes");
        return null;
      }
      
      let publicKey: CryptographicPoint;
      
      // Handle different public key formats using bitcoinjs
      if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
        // Uncompressed key (04 + x + y)
        const xBytes = pubKeyBytes.slice(1, 33);
        const yBytes = pubKeyBytes.slice(33, 65);
        
        const xHex = bytesToHex(xBytes);
        const yHex = bytesToHex(yBytes);
        
        publicKey = {
          x: xHex,
          y: yHex,
          isOnCurve: true // We'll validate this later
        };
        
        console.log("Extracted uncompressed public key:", 
          "x:", publicKey.x.substring(0, 10) + "...", 
          "y:", publicKey.y.substring(0, 10) + "...");
      }
      else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
        // Compressed key (02/03 + x)
        try {
          const pubKeyHex = bytesToHex(pubKeyBytes);
          
          // Use secp256k1 library directly to decompress the key
          if (window.secp256k1) {
            const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
            
            // Extract x and y coordinates (format: 04 | x | y)
            const xBytes = decompressed.slice(1, 33);
            const yBytes = decompressed.slice(33, 65);
            
            const xHex = bytesToHex(xBytes);
            const yHex = bytesToHex(yBytes);
            
            publicKey = {
              x: xHex,
              y: yHex,
              isOnCurve: true
            };
          } else {
            // Fall back to our utility function if secp256k1 isn't available
            const decomp = decompressPublicKey(pubKeyHex);
            
            publicKey = {
              x: decomp.x,
              y: decomp.y,
              isOnCurve: decomp.isOnCurve
            };
          }
          
          console.log("Decompressed compressed public key:", 
            "x:", publicKey.x.substring(0, 10) + "...", 
            "y:", publicKey.y.substring(0, 10) + "...");
        } catch (decompError) {
          console.error("Error decompressing public key:", decompError);
          return null;
        }
      } else {
        console.log("Invalid public key format. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
        return null;
      }
      
      return { signature, publicKey };
    } catch (parseError) {
      console.error("Error parsing signature or using Bitcoin ECDSA:", parseError);
      
      // Try fallback manual DER parsing if the bitcoinjs method failed
      try {
        // Manual DER parsing as fallback
        let pos = 1; // Skip '30'
        const totalLen = sigBytes[pos];
        pos++;
        
        if (sigBytes[pos] !== 0x02) {
          throw new Error('Invalid DER signature: missing first integer marker');
        }
        pos++;
        
        const rLen = sigBytes[pos];
        pos++;
        const rValue = sigBytes.slice(pos, pos + rLen);
        pos += rLen;
        
        if (sigBytes[pos] !== 0x02) {
          throw new Error('Invalid DER signature: missing second integer marker');
        }
        pos++;
        
        const sLen = sigBytes[pos];
        pos++;
        const sValue = sigBytes.slice(pos, pos + sLen);
        
        // Get sighash byte (last byte)
        const sighashType = sigBytes[sigBytes.length - 1];
        
        // Convert to hex
        const rHex = bytesToHex(rValue).padStart(64, '0');
        const sHex = bytesToHex(sValue).padStart(64, '0');
        const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
        
        const signature: Signature = {
          r: rHex,
          s: sHex,
          sighash: sighashHex
        };
        
        console.log("Extracted signature using fallback method:", 
          "r:", signature.r.substring(0, 10) + "...", 
          "s:", signature.s.substring(0, 10) + "...");
        
        // Extract public key (same as above)
        const pubKeyBytes = pubKeyChunk;
        if (!pubKeyBytes || pubKeyBytes.length === 0) {
          console.log("Empty public key bytes");
          return null;
        }
        
        let publicKey: CryptographicPoint;
        
        if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
          // Uncompressed key (04 + x + y)
          const xBytes = pubKeyBytes.slice(1, 33);
          const yBytes = pubKeyBytes.slice(33, 65);
          
          const xHex = bytesToHex(xBytes);
          const yHex = bytesToHex(yBytes);
          
          publicKey = {
            x: xHex,
            y: yHex,
            isOnCurve: true // We'll validate this later
          };
          
          console.log("Extracted uncompressed public key:", 
            "x:", publicKey.x.substring(0, 10) + "...", 
            "y:", publicKey.y.substring(0, 10) + "...");
        }
        else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
          // Compressed key (02/03 + x)
          try {
            const pubKeyHex = bytesToHex(pubKeyBytes);
            
            // Use our decompressPublicKey utility
            const decomp = decompressPublicKey(pubKeyHex);
            
            publicKey = {
              x: decomp.x,
              y: decomp.y,
              isOnCurve: decomp.isOnCurve
            };
            
            console.log("Decompressed compressed public key:", 
              "x:", publicKey.x.substring(0, 10) + "...", 
              "y:", publicKey.y.substring(0, 10) + "...");
          } catch (decompError) {
            console.error("Error decompressing public key:", decompError);
            return null;
          }
        } else {
          console.log("Invalid public key format. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
          return null;
        }
        
        return { signature, publicKey };
      } catch (fallbackError) {
        console.error("Fallback parsing also failed:", fallbackError);
        return null;
      }
    }
  } catch (error) {
    console.error("Error extracting P2PKH data:", error);
    return null;
  }
};
