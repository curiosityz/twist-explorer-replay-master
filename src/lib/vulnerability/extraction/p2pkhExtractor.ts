
import { CryptographicPoint, Signature } from '@/types';
import { bytesToHex } from './hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoinLibsCheck';

/**
 * Extract cryptographic data from P2PKH input
 * @param scriptSigHex Hex string of scriptSig
 * @returns Extracted signature and public key or null
 */
export const extractP2PKHData = (scriptSigHex: string): { signature: Signature, publicKey: CryptographicPoint } | null => {
  try {
    // Check if libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
      throw new Error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
    }
    
    // Safety check for scriptSigHex
    if (!scriptSigHex || scriptSigHex.length < 10) {
      console.error("Invalid scriptSig hex data");
      return null;
    }
    
    let scriptSig;
    try {
      // Use bitcoinjs to parse the script
      scriptSig = window.Bitcoin.Script.fromHex(scriptSigHex);
    } catch (scriptError) {
      console.error("Failed to parse scriptSig hex:", scriptError);
      return null;
    }
    
    if (!scriptSig || !scriptSig.chunks || scriptSig.chunks.length < 2) {
      console.log("Invalid script structure, chunks:", scriptSig?.chunks?.length || 0);
      return null;
    }
    
    // P2PKH typically has 2 chunks: signature and public key
    const sigChunk = scriptSig.chunks[0];
    const pubKeyChunk = scriptSig.chunks[1];
    
    if (!sigChunk || !pubKeyChunk) {
      console.log("Missing signature or public key chunk");
      return null;
    }
    
    console.log("Found potential scriptSig chunks");
    
    // Extract signature (DER format with sighash byte at the end)
    const sigBytes = sigChunk;
    if (!sigBytes || sigBytes.length === 0) {
      console.log("Empty signature bytes");
      return null;
    }
    
    // Usually, the signature starts with 0x30
    if (sigBytes[0] !== 0x30) {
      console.log("Invalid signature format, first byte:", sigBytes[0]);
      return null;
    }
    
    // Parse DER format with better error handling
    try {
      let pos = 2; // Skip 0x30 and length byte
      
      // R value
      if (sigBytes[pos] !== 0x02) {
        console.log("Invalid R value format");
        return null;
      }
      
      pos++;
      const rLen = sigBytes[pos];
      pos++;
      const rValue = sigBytes.slice(pos, pos + rLen);
      pos += rLen;
      
      // S value
      if (pos >= sigBytes.length || sigBytes[pos] !== 0x02) { 
        console.log("Invalid S value format or out of bounds");
        return null;
      }
      
      pos++;
      if (pos >= sigBytes.length) {
        console.log("S length byte out of bounds");
        return null;
      }
      
      const sLen = sigBytes[pos];
      pos++;
      
      if (pos + sLen > sigBytes.length) {
        console.log("S value out of bounds");
        return null;
      }
      
      const sValue = sigBytes.slice(pos, pos + sLen);
      pos += sLen;
      
      // Get sighash byte (last byte)
      const sighashType = sigBytes[sigBytes.length - 1];
      
      // Convert to hex
      const rHex = bytesToHex(rValue);
      const sHex = bytesToHex(sValue);
      const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
      
      const signature: Signature = {
        r: rHex,
        s: sHex,
        sighash: sighashHex
      };
      
      console.log("Extracted signature from DER:", 
        "r:", signature.r.substring(0, 10) + "...", 
        "s:", signature.s.substring(0, 10) + "...");
      
      // Extract public key
      const pubKeyBytes = pubKeyChunk;
      if (!pubKeyBytes || pubKeyBytes.length === 0) {
        console.log("Empty public key bytes");
        return null;
      }
      
      let publicKey: CryptographicPoint;
      
      // Check if it's a valid public key format
      if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
        // Uncompressed key (04 + x + y)
        const xBytes = pubKeyBytes.slice(1, 33);
        const yBytes = pubKeyBytes.slice(33, 65);
        
        const xHex = bytesToHex(xBytes);
        const yHex = bytesToHex(yBytes);
        
        publicKey = {
          x: xHex,
          y: yHex,
          isOnCurve: true // We'll check this in the analysis
        };
        
        console.log("Extracted uncompressed public key:", 
          "x:", publicKey.x.substring(0, 10) + "...", 
          "y:", publicKey.y.substring(0, 10) + "...");
      }
      else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
        // Compressed key (02/03 + x)
        try {
          const pubKeyHex = bytesToHex(pubKeyBytes);
          
          // Use our decompressPublicKey utility
          const decomp = decompressPublicKey(pubKeyHex);
          
          publicKey = {
            x: decomp.x,
            y: decomp.y,
            isOnCurve: decomp.isOnCurve
          };
          
          console.log("Decompressed compressed public key:", 
            "x:", publicKey.x.substring(0, 10) + "...", 
            "y:", publicKey.y.substring(0, 10) + "...");
        } catch (decompError) {
          console.error("Error decompressing public key:", decompError);
          return null;
        }
      } else {
        console.log("Invalid public key format. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
        return null;
      }
      
      return { signature, publicKey };
    } catch (parseError) {
      console.error("Error parsing DER signature:", parseError);
      return null;
    }
  } catch (error) {
    console.error("Error extracting P2PKH data:", error);
    return null;
  }
};
