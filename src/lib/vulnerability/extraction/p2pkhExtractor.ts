
import { CryptographicPoint, Signature } from '@/types';
import { bytesToHex } from './hexUtils';
import { decompressPublicKey } from '@/lib/crypto/bitcoinUtilities';

/**
 * Extract cryptographic data from P2PKH input
 * @param scriptSigHex Hex string of scriptSig
 * @returns Extracted signature and public key or null
 */
export const extractP2PKHData = (scriptSigHex: string): { signature: Signature, publicKey: CryptographicPoint } | null => {
  try {
    if (!window.Bitcoin) {
      throw new Error("Bitcoin library not loaded");
    }
    
    // Use bitcoinjs to parse the script
    const scriptSig = window.Bitcoin.Script.fromHex(scriptSigHex);
    
    if (!scriptSig || !scriptSig.chunks || scriptSig.chunks.length < 2) {
      console.log("Invalid script structure");
      return null;
    }
    
    // P2PKH typically has 2 chunks: signature and public key
    const sigChunk = scriptSig.chunks[0];
    const pubKeyChunk = scriptSig.chunks[1];
    
    if (!sigChunk || !pubKeyChunk) {
      console.log("Missing signature or public key chunk");
      return null;
    }
    
    console.log("Found potential scriptSig chunks");
    
    // Extract signature (DER format with sighash byte at the end)
    const sigBytes = sigChunk;
    if (!sigBytes || sigBytes.length === 0) {
      console.log("Empty signature bytes");
      return null;
    }
    
    // Usually, the signature starts with 0x30
    if (sigBytes[0] !== 0x30) {
      console.log("Invalid signature format");
      return null;
    }
    
    // Parse DER format
    let pos = 2; // Skip 0x30 and length byte
    
    // R value
    if (sigBytes[pos] !== 0x02) {
      console.log("Invalid R value format");
      return null;
    }
    
    pos++;
    const rLen = sigBytes[pos];
    pos++;
    const rValue = sigBytes.slice(pos, pos + rLen);
    pos += rLen;
    
    // S value
    if (sigBytes[pos] !== 0x02) { 
      console.log("Invalid S value format");
      return null;
    }
    
    pos++;
    const sLen = sigBytes[pos];
    pos++;
    const sValue = sigBytes.slice(pos, pos + sLen);
    pos += sLen;
    
    // Get sighash byte (last byte)
    const sighashType = sigBytes[sigBytes.length - 1];
    
    // Convert to hex
    const rHex = bytesToHex(rValue);
    const sHex = bytesToHex(sValue);
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    const signature: Signature = {
      r: rHex,
      s: sHex,
      sighash: sighashHex
    };
    
    console.log("Extracted signature from DER:", 
      "r:", signature.r.substring(0, 10) + "...", 
      "s:", signature.s.substring(0, 10) + "...");
    
    // Extract public key
    const pubKeyBytes = pubKeyChunk;
    if (!pubKeyBytes || pubKeyBytes.length === 0) {
      console.log("Empty public key bytes");
      return null;
    }
    
    let publicKey: CryptographicPoint;
    
    // Check if it's a valid public key format
    if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
      // Uncompressed key (04 + x + y)
      const xBytes = pubKeyBytes.slice(1, 33);
      const yBytes = pubKeyBytes.slice(33, 65);
      
      const xHex = bytesToHex(xBytes);
      const yHex = bytesToHex(yBytes);
      
      publicKey = {
        x: xHex,
        y: yHex,
        isOnCurve: true // We'll check this in the analysis
      };
      
      console.log("Extracted uncompressed public key:", 
        "x:", publicKey.x.substring(0, 10) + "...", 
        "y:", publicKey.y.substring(0, 10) + "...");
    }
    else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
      // Compressed key (02/03 + x)
      try {
        // Use our decompressPublicKey utility
        const pubKeyHex = bytesToHex(pubKeyBytes);
        const decomp = decompressPublicKey(pubKeyHex);
        
        publicKey = {
          x: decomp.x,
          y: decomp.y,
          isOnCurve: decomp.isOnCurve
        };
        
        console.log("Decompressed compressed public key:", 
          "x:", publicKey.x.substring(0, 10) + "...", 
          "y:", publicKey.y.substring(0, 10) + "...");
      } catch (err) {
        console.error("Error decompressing public key:", err);
        return null;
      }
    } else {
      console.log("Invalid public key format");
      return null;
    }
    
    return { signature, publicKey };
  } catch (error) {
    console.error("Error extracting P2PKH data:", error);
    return null;
  }
};
