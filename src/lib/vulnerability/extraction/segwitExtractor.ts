
import { CryptographicPoint, Signature } from '@/types';
import { bytesToHex, hexToBytes } from './hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoinLibsCheck';

/**
 * Extract cryptographic data from segwit witness data
 * @param witnessData Array of witness data from transaction
 * @returns Extracted signature and public key or null
 */
export const extractSegWitData = (witnessData: string[]): { signature: Signature, publicKey: CryptographicPoint } | null => {
  try {
    // Check if libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
      throw new Error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
    }
    
    if (!witnessData || witnessData.length < 2) {
      console.log("Insufficient witness data");
      return null;
    }
    
    // Log the witness data for debugging
    console.log("Processing witness data:", witnessData);
    
    const sigHex = witnessData[0];
    const pubKeyHex = witnessData[1];
    
    if (!sigHex || !pubKeyHex) {
      console.log("Missing signature or public key in witness data");
      return null;
    }
    
    // Safety checks
    if (sigHex.length < 10 || pubKeyHex.length < 10) {
      console.log("Invalid signature or public key length in witness data");
      return null;
    }
    
    // Parse signature from witness
    try {
      const sigBytes = hexToBytes(sigHex);
      
      if (!sigBytes || sigBytes.length === 0) {
        console.log("Empty signature bytes");
        return null;
      }
      
      // Usually, the signature starts with 0x30
      if (sigBytes[0] !== 0x30) {
        console.log("Invalid signature format in witness, first byte:", sigBytes[0]);
        return null;
      }
      
      // Parse DER format with better error handling
      let pos = 2; // Skip 0x30 and length byte
      
      // R value
      if (pos >= sigBytes.length || sigBytes[pos] !== 0x02) {
        console.log("Invalid R value format in witness or out of bounds");
        return null;
      }
      
      pos++;
      if (pos >= sigBytes.length) {
        console.log("R length byte out of bounds");
        return null;
      }
      
      const rLen = sigBytes[pos];
      pos++;
      
      if (pos + rLen > sigBytes.length) {
        console.log("R value out of bounds");
        return null;
      }
      
      const rValue = sigBytes.slice(pos, pos + rLen);
      pos += rLen;
      
      // S value
      if (pos >= sigBytes.length || sigBytes[pos] !== 0x02) {
        console.log("Invalid S value format in witness or out of bounds");
        return null;
      }
      
      pos++;
      if (pos >= sigBytes.length) {
        console.log("S length byte out of bounds");
        return null;
      }
      
      const sLen = sigBytes[pos];
      pos++;
      
      if (pos + sLen > sigBytes.length) {
        console.log("S value out of bounds");
        return null;
      }
      
      const sValue = sigBytes.slice(pos, pos + sLen);
      
      // Get sighash byte (last byte)
      const sighashType = sigBytes[sigBytes.length - 1];
      
      // Convert to hex
      const rHex = bytesToHex(rValue);
      const sHex = bytesToHex(sValue);
      const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
      
      const signature: Signature = {
        r: rHex,
        s: sHex,
        sighash: sighashHex
      };
      
      console.log("Extracted signature from witness:", 
        "r:", signature.r.substring(0, 10) + "...", 
        "s:", signature.s.substring(0, 10) + "...");
      
      // Parse public key from witness with error handling
      try {
        const pubKeyBytes = hexToBytes(pubKeyHex);
        
        if (!pubKeyBytes || pubKeyBytes.length === 0) {
          console.log("Empty public key bytes in witness");
          return null;
        }
        
        let publicKey: CryptographicPoint;
        
        // Check if it's a valid public key format
        if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
          // Uncompressed key (04 + x + y)
          const xBytes = pubKeyBytes.slice(1, 33);
          const yBytes = pubKeyBytes.slice(33, 65);
          
          const xHex = bytesToHex(xBytes);
          const yHex = bytesToHex(yBytes);
          
          publicKey = {
            x: xHex,
            y: yHex,
            isOnCurve: true
          };
          
          console.log("Extracted uncompressed public key from witness:", 
            "x:", publicKey.x.substring(0, 10) + "...", 
            "y:", publicKey.y.substring(0, 10) + "...");
        }
        else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
          // Compressed key (02/03 + x)
          try {
            // Use our decompressPublicKey utility
            const decomp = decompressPublicKey(pubKeyHex);
            
            publicKey = {
              x: decomp.x,
              y: decomp.y,
              isOnCurve: decomp.isOnCurve
            };
            
            console.log("Decompressed compressed public key from witness:", 
              "x:", publicKey.x.substring(0, 10) + "...", 
              "y:", publicKey.y.substring(0, 10) + "...");
          } catch (decompError) {
            console.error("Error decompressing witness public key:", decompError);
            return null;
          }
        } else {
          console.log("Invalid public key format in witness. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
          return null;
        }
        
        return { signature, publicKey };
      } catch (pubkeyError) {
        console.error("Error processing public key from witness:", pubkeyError);
        return null;
      }
    } catch (sigError) {
      console.error("Error processing signature from witness:", sigError);
      return null;
    }
  } catch (error) {
    console.error("Error extracting SegWit data:", error);
    return null;
  }
};
