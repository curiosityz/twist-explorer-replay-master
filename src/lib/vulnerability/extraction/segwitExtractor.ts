
import { CryptographicPoint, Signature } from '@/types';
import { bytesToHex, hexToBytes } from './hexUtils';
import { decompressPublicKey } from '@/lib/crypto/bitcoinUtilities';

/**
 * Extract cryptographic data from segwit witness data
 * @param witnessData Array of witness data from transaction
 * @returns Extracted signature and public key or null
 */
export const extractSegWitData = (witnessData: string[]): { signature: Signature, publicKey: CryptographicPoint } | null => {
  try {
    if (!witnessData || witnessData.length < 2) {
      console.log("Insufficient witness data");
      return null;
    }
    
    const sigHex = witnessData[0];
    const pubKeyHex = witnessData[1];
    
    if (!sigHex || !pubKeyHex) {
      console.log("Missing signature or public key in witness data");
      return null;
    }
    
    // Parse signature from witness
    const sigBytes = hexToBytes(sigHex);
    
    if (!sigBytes || sigBytes.length === 0) {
      console.log("Empty signature bytes");
      return null;
    }
    
    // Usually, the signature starts with 0x30
    if (sigBytes[0] !== 0x30) {
      console.log("Invalid signature format in witness");
      return null;
    }
    
    // Parse DER format
    let pos = 2; // Skip 0x30 and length byte
    
    // R value
    if (sigBytes[pos] !== 0x02) {
      console.log("Invalid R value format in witness");
      return null;
    }
    
    pos++;
    const rLen = sigBytes[pos];
    pos++;
    const rValue = sigBytes.slice(pos, pos + rLen);
    pos += rLen;
    
    // S value
    if (sigBytes[pos] !== 0x02) {
      console.log("Invalid S value format in witness");
      return null;
    }
    
    pos++;
    const sLen = sigBytes[pos];
    pos++;
    const sValue = sigBytes.slice(pos, pos + sLen);
    
    // Get sighash byte (last byte)
    const sighashType = sigBytes[sigBytes.length - 1];
    
    // Convert to hex
    const rHex = bytesToHex(rValue);
    const sHex = bytesToHex(sValue);
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    const signature: Signature = {
      r: rHex,
      s: sHex,
      sighash: sighashHex
    };
    
    console.log("Extracted signature from witness:", 
      "r:", signature.r.substring(0, 10) + "...", 
      "s:", signature.s.substring(0, 10) + "...");
    
    // Parse public key from witness
    const pubKeyBytes = hexToBytes(pubKeyHex);
    
    if (!pubKeyBytes || pubKeyBytes.length === 0) {
      console.log("Empty public key bytes in witness");
      return null;
    }
    
    let publicKey: CryptographicPoint;
    
    // Check if it's a valid public key format
    if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
      // Uncompressed key (04 + x + y)
      const xBytes = pubKeyBytes.slice(1, 33);
      const yBytes = pubKeyBytes.slice(33, 65);
      
      const xHex = bytesToHex(xBytes);
      const yHex = bytesToHex(yBytes);
      
      publicKey = {
        x: xHex,
        y: yHex,
        isOnCurve: true
      };
      
      console.log("Extracted uncompressed public key from witness:", 
        "x:", publicKey.x.substring(0, 10) + "...", 
        "y:", publicKey.y.substring(0, 10) + "...");
    }
    else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
      // Compressed key (02/03 + x)
      try {
        // Use our decompressPublicKey utility
        const decomp = decompressPublicKey(pubKeyHex);
        
        publicKey = {
          x: decomp.x,
          y: decomp.y,
          isOnCurve: decomp.isOnCurve
        };
        
        console.log("Decompressed compressed public key from witness:", 
          "x:", publicKey.x.substring(0, 10) + "...", 
          "y:", publicKey.y.substring(0, 10) + "...");
      } catch (err) {
        console.error("Error decompressing witness public key:", err);
        return null;
      }
    } else {
      console.log("Invalid public key format in witness");
      return null;
    }
    
    return { signature, publicKey };
  } catch (error) {
    console.error("Error extracting SegWit data:", error);
    return null;
  }
};
