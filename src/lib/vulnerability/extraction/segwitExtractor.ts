
import { CryptographicPoint, Signature } from '@/types';
import { bytesToHex, hexToBytes } from './hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoinLibsCheck';

/**
 * Extract cryptographic data from segwit witness data
 * @param witnessData Array of witness data from transaction
 * @returns Extracted signature and public key or null
 */
export const extractSegWitData = (witnessData: string[]): { signature: Signature, publicKey: CryptographicPoint } | null => {
  try {
    // Check if libraries are loaded
    const libsCheck = checkBitcoinLibsLoaded();
    if (!libsCheck.loaded) {
      console.error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
      throw new Error(`Bitcoin libraries not loaded: Missing ${libsCheck.missing.join(', ')}`);
    }
    
    if (!witnessData || witnessData.length < 2) {
      console.log("Insufficient witness data");
      return null;
    }
    
    // Log the witness data for debugging
    console.log("Processing witness data:", witnessData);
    
    const sigHex = witnessData[0];
    const pubKeyHex = witnessData[1];
    
    if (!sigHex || !pubKeyHex) {
      console.log("Missing signature or public key in witness data");
      return null;
    }
    
    // Safety checks
    if (sigHex.length < 10 || pubKeyHex.length < 10) {
      console.log("Invalid signature or public key length in witness data");
      return null;
    }

    // Parse signature from witness
    try {
      const sigBytes = hexToBytes(sigHex);
      
      if (!sigBytes || sigBytes.length === 0) {
        console.log("Empty signature bytes");
        return null;
      }
      
      // Use Bitcoin ECDSA parser if available
      if (window.Bitcoin && window.Bitcoin.ECDSA) {
        try {
          const sigData = window.Bitcoin.ECDSA.parseSig(sigHex);
          
          const signature: Signature = {
            r: sigData.r.toString(16).padStart(64, '0'),
            s: sigData.s.toString(16).padStart(64, '0'),
            sighash: ('0' + sigBytes[sigBytes.length - 1].toString(16)).slice(-2)
          };
          
          console.log("Extracted signature using Bitcoin.ECDSA:", 
            "r:", signature.r.substring(0, 10) + "...", 
            "s:", signature.s.substring(0, 10) + "...");
          
          // Process public key similarly to P2PKH
          const pubKeyBytes = hexToBytes(pubKeyHex);
          
          if (!pubKeyBytes || pubKeyBytes.length === 0) {
            console.log("Empty public key bytes in witness");
            return null;
          }
          
          let publicKey: CryptographicPoint;
          
          if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
            // Uncompressed key (04 + x + y)
            const xBytes = pubKeyBytes.slice(1, 33);
            const yBytes = pubKeyBytes.slice(33, 65);
            
            const xHex = bytesToHex(xBytes);
            const yHex = bytesToHex(yBytes);
            
            publicKey = {
              x: xHex,
              y: yHex,
              isOnCurve: true
            };
            
            console.log("Extracted uncompressed public key from witness:", 
              "x:", publicKey.x.substring(0, 10) + "...", 
              "y:", publicKey.y.substring(0, 10) + "...");
          }
          else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
            // Use secp256k1 library directly to decompress the key if available
            if (window.secp256k1) {
              try {
                const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
                
                // Extract x and y coordinates (format: 04 | x | y)
                const xBytes = decompressed.slice(1, 33);
                const yBytes = decompressed.slice(33, 65);
                
                const xHex = bytesToHex(xBytes);
                const yHex = bytesToHex(yBytes);
                
                publicKey = {
                  x: xHex,
                  y: yHex,
                  isOnCurve: true
                };
                
                console.log("Decompressed witness public key using secp256k1:", 
                  "x:", publicKey.x.substring(0, 10) + "...", 
                  "y:", publicKey.y.substring(0, 10) + "...");
              } catch (secp256k1Error) {
                console.error("Error using secp256k1 to decompress key:", secp256k1Error);
                
                // Fall back to our utility if secp256k1 direct call fails
                const decomp = decompressPublicKey(pubKeyHex);
                
                publicKey = {
                  x: decomp.x,
                  y: decomp.y,
                  isOnCurve: decomp.isOnCurve
                };
              }
            } else {
              // Fall back to our utility function if secp256k1 isn't available
              const decomp = decompressPublicKey(pubKeyHex);
              
              publicKey = {
                x: decomp.x,
                y: decomp.y,
                isOnCurve: decomp.isOnCurve
              };
              
              console.log("Decompressed witness public key using utility:", 
                "x:", publicKey.x.substring(0, 10) + "...", 
                "y:", publicKey.y.substring(0, 10) + "...");
            }
          } else {
            console.log("Invalid public key format in witness. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
            return null;
          }
          
          return { signature, publicKey };
        } catch (ecdsaError) {
          console.error("Error using Bitcoin.ECDSA for parsing:", ecdsaError);
          // Fall back to manual parsing
        }
      }
      
      // Manual DER parsing as fallback
      // Usually, the signature starts with 0x30
      if (sigBytes[0] !== 0x30) {
        console.log("Invalid signature format in witness, first byte:", sigBytes[0]);
        return null;
      }
      
      // Parse DER format with better error handling
      let pos = 1; // Start after signature header (0x30)
      const totalLen = sigBytes[pos];
      pos++;
      
      // R value
      if (sigBytes[pos] !== 0x02) {
        console.error("Invalid R value format in witness");
        return null;
      }
      
      pos++;
      const rLen = sigBytes[pos];
      pos++;
      const rValue = sigBytes.slice(pos, pos + rLen);
      pos += rLen;
      
      // S value
      if (sigBytes[pos] !== 0x02) {
        console.error("Invalid S value format in witness");
        return null;
      }
      
      pos++;
      const sLen = sigBytes[pos];
      pos++;
      const sValue = sigBytes.slice(pos, pos + sLen);
      
      // Get sighash byte (last byte)
      const sighashType = sigBytes[sigBytes.length - 1];
      
      // Convert to hex
      const rHex = bytesToHex(rValue).padStart(64, '0');
      const sHex = bytesToHex(sValue).padStart(64, '0');
      const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
      
      const signature: Signature = {
        r: rHex,
        s: sHex,
        sighash: sighashHex
      };
      
      console.log("Extracted signature from witness using manual parsing:", 
        "r:", signature.r.substring(0, 10) + "...", 
        "s:", signature.s.substring(0, 10) + "...");
      
      // Parse public key from witness with error handling
      try {
        const pubKeyBytes = hexToBytes(pubKeyHex);
        
        if (!pubKeyBytes || pubKeyBytes.length === 0) {
          console.log("Empty public key bytes in witness");
          return null;
        }
        
        let publicKey: CryptographicPoint;
        
        // Check if it's a valid public key format
        if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
          // Uncompressed key (04 + x + y)
          const xBytes = pubKeyBytes.slice(1, 33);
          const yBytes = pubKeyBytes.slice(33, 65);
          
          const xHex = bytesToHex(xBytes);
          const yHex = bytesToHex(yBytes);
          
          publicKey = {
            x: xHex,
            y: yHex,
            isOnCurve: true
          };
          
          console.log("Extracted uncompressed public key from witness:", 
            "x:", publicKey.x.substring(0, 10) + "...", 
            "y:", publicKey.y.substring(0, 10) + "...");
        }
        else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
          // Compressed key (02/03 + x)
          try {
            if (window.secp256k1) {
              // Use secp256k1 library directly if available
              const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
              
              const xBytes = decompressed.slice(1, 33);
              const yBytes = decompressed.slice(33, 65);
              
              publicKey = {
                x: bytesToHex(xBytes),
                y: bytesToHex(yBytes),
                isOnCurve: true
              };
            } else {
              // Use our decompressPublicKey utility as fallback
              const decomp = decompressPublicKey(pubKeyHex);
              
              publicKey = {
                x: decomp.x,
                y: decomp.y,
                isOnCurve: decomp.isOnCurve
              };
            }
            
            console.log("Decompressed compressed public key from witness:", 
              "x:", publicKey.x.substring(0, 10) + "...", 
              "y:", publicKey.y.substring(0, 10) + "...");
          } catch (decompError) {
            console.error("Error decompressing witness public key:", decompError);
            return null;
          }
        } else {
          console.log("Invalid public key format in witness. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
          return null;
        }
        
        return { signature, publicKey };
      } catch (pubkeyError) {
        console.error("Error processing public key from witness:", pubkeyError);
        return null;
      }
    } catch (sigError) {
      console.error("Error processing signature from witness:", sigError);
      return null;
    }
  } catch (error) {
    console.error("Error extracting SegWit data:", error);
    return null;
  }
};
