
/**
 * Parse SegWit witness data from transactions
 */

import { bytesToHex, hexToBytes } from '../hexUtils';
import { extractWitnessPublicKey } from './witnessPublicKeyExtractor';
import { extractWitnessSignature } from './witnessSignatureExtractor';

/**
 * Parse witness data from a transaction input
 * @param witness Witness data from transaction input
 * @returns Object containing signature and public key hex strings, or null
 */
export const parseWitnessData = (witness: string[] | any): { sigHex: string; pubKeyHex: string } | null => {
  try {
    if (!witness || !Array.isArray(witness)) {
      console.error("Invalid witness format:", witness);
      return null;
    }

    console.log(`Parsing witness data with ${witness.length} items`);
    
    // Different witness patterns
    // P2WPKH: [signature, publicKey]
    // P2WSH: variable, but often [0, sig1, sig2, ..., redeemScript]
    
    if (witness.length === 2) {
      // Standard P2WPKH witness
      const sigHex = witness[0];
      const pubKeyHex = witness[1];
      
      return { sigHex, pubKeyHex };
    } else if (witness.length > 2) {
      // Possibly P2WSH or more complex script
      // Try to extract from likely positions
      let sigIndex = -1;
      let pubKeyIndex = -1;
      
      // Look for likely signature (starts with 3044/3045/3046)
      for (let i = 0; i < witness.length; i++) {
        const item = witness[i];
        if (typeof item === 'string' && 
            (item.startsWith('3044') || item.startsWith('3045') || item.startsWith('3046'))) {
          sigIndex = i;
          break;
        }
      }
      
      // Look for likely public key (starts with 02/03/04)
      for (let i = 0; i < witness.length; i++) {
        const item = witness[i];
        if (typeof item === 'string' && 
            (item.startsWith('02') || item.startsWith('03') || item.startsWith('04'))) {
          // Additional validation for likely pubkey length
          if (item.length === 66 || item.length === 130) {
            pubKeyIndex = i;
            break;
          }
        }
      }
      
      if (sigIndex >= 0 && pubKeyIndex >= 0) {
        return {
          sigHex: witness[sigIndex],
          pubKeyHex: witness[pubKeyIndex]
        };
      }
      
      console.error("Could not identify signature and public key in witness stack");
    }
    
    return null;
  } catch (error) {
    console.error("Error parsing witness data:", error);
    return null;
  }
};

/**
 * Convert signature hex to bytes
 * @param sigHex Signature in hex format
 * @returns Signature as Uint8Array or null
 */
export const getSignatureBytes = (sigHex: string): Uint8Array | null => {
  try {
    if (!sigHex || typeof sigHex !== 'string') {
      console.error("Invalid signature hex:", sigHex);
      return null;
    }
    
    return hexToBytes(sigHex);
  } catch (error) {
    console.error("Error converting signature hex to bytes:", error);
    return null;
  }
};

/**
 * Convert public key hex to bytes
 * @param pubKeyHex Public key in hex format
 * @returns Public key as Uint8Array or null
 */
export const getPublicKeyBytes = (pubKeyHex: string): Uint8Array | null => {
  try {
    if (!pubKeyHex || typeof pubKeyHex !== 'string') {
      console.error("Invalid public key hex:", pubKeyHex);
      return null;
    }
    
    return hexToBytes(pubKeyHex);
  } catch (error) {
    console.error("Error converting public key hex to bytes:", error);
    return null;
  }
};
