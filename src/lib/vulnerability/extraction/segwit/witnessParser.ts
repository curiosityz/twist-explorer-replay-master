
/**
 * Parse SegWit witness data from transactions
 */

import { bytesToHex, hexToBytes } from '../hexUtils';
import { extractWitnessPublicKey } from './witnessPublicKeyExtractor';
import { extractWitnessSignature } from './witnessSignatureExtractor';

/**
 * Parse witness stack from a transaction input
 * @param witness Witness data from transaction input
 * @returns Object containing extracted signature and public key, or null
 */
export const parseWitnessStack = (witness: string[] | any): { signature: any; publicKey: any } | null => {
  try {
    if (!witness || !Array.isArray(witness)) {
      console.error("Invalid witness format:", witness);
      return null;
    }

    console.log(`Parsing witness stack with ${witness.length} items`);
    
    // Different witness patterns
    // P2WPKH: [signature, publicKey]
    // P2WSH: variable, but often [0, sig1, sig2, ..., redeemScript]
    
    if (witness.length === 2) {
      // Standard P2WPKH witness
      const sigHex = witness[0];
      const pubKeyHex = witness[1];
      
      const sigBytes = hexToBytes(sigHex);
      const pubKeyBytes = hexToBytes(pubKeyHex);
      
      // Extract signature
      const signature = extractWitnessSignature(sigBytes);
      if (!signature) {
        console.error("Failed to extract signature from witness");
        return null;
      }
      
      // Extract public key
      const publicKey = extractWitnessPublicKey(pubKeyBytes);
      if (!publicKey) {
        console.error("Failed to extract public key from witness");
        return null;
      }
      
      return { signature, publicKey };
    } else if (witness.length > 2) {
      // Possibly P2WSH or more complex script
      // Try to extract from likely positions
      let sigIndex = -1;
      let pubKeyIndex = -1;
      
      // Look for likely signature (starts with 3044/3045/3046)
      for (let i = 0; i < witness.length; i++) {
        const item = witness[i];
        if (typeof item === 'string' && 
            (item.startsWith('3044') || item.startsWith('3045') || item.startsWith('3046'))) {
          sigIndex = i;
          break;
        }
      }
      
      // Look for likely public key (starts with 02/03/04)
      for (let i = 0; i < witness.length; i++) {
        const item = witness[i];
        if (typeof item === 'string' && 
            (item.startsWith('02') || item.startsWith('03') || item.startsWith('04'))) {
          // Additional validation for likely pubkey length
          if (item.length === 66 || item.length === 130) {
            pubKeyIndex = i;
            break;
          }
        }
      }
      
      if (sigIndex >= 0 && pubKeyIndex >= 0) {
        // Convert from hex to bytes
        const sigBytes = hexToBytes(witness[sigIndex]);
        const pubKeyBytes = hexToBytes(witness[pubKeyIndex]);
        
        // Ensure we're using Uint8Array
        const sigBytesArray = sigBytes instanceof Uint8Array ? 
          sigBytes : new Uint8Array(sigBytes);
        const pubKeyBytesArray = pubKeyBytes instanceof Uint8Array ? 
          pubKeyBytes : new Uint8Array(pubKeyBytes);
        
        // Extract signature and public key
        const signature = extractWitnessSignature(sigBytesArray);
        const publicKey = extractWitnessPublicKey(pubKeyBytesArray);
        
        if (signature && publicKey) {
          return { signature, publicKey };
        }
      }
      
      console.error("Could not identify signature and public key in witness stack");
    }
    
    return null;
  } catch (error) {
    console.error("Error parsing witness stack:", error);
    return null;
  }
};
