
/**
 * Parse witness data from SegWit transactions
 */

import { bytesToHex, hexToBytes } from '../hexUtils';

/**
 * Parse witness data from a transaction input
 * @param witnessData Witness data array from transaction
 * @returns Object containing signature and public key hex, or null if invalid
 */
export const parseWitnessData = (witnessData: string[] | any[]): { sigHex: string, pubKeyHex: string } | null => {
  try {
    if (!witnessData || !Array.isArray(witnessData) || witnessData.length < 2) {
      console.log("Invalid witness data format");
      return null;
    }
    
    // In SegWit P2WPKH, the witness stack has two items:
    // [0] = Signature (with sighash byte)
    // [1] = Public key
    const sigHex = witnessData[0];
    const pubKeyHex = witnessData[1];
    
    if (!sigHex || !pubKeyHex || typeof sigHex !== 'string' || typeof pubKeyHex !== 'string') {
      console.log("Invalid signature or public key in witness data");
      return null;
    }
    
    return { sigHex, pubKeyHex };
  } catch (error) {
    console.error("Error parsing witness data:", error);
    return null;
  }
};

/**
 * Get signature bytes from hex string
 * @param sigHex Signature hex string
 * @returns Uint8Array of signature bytes
 */
export const getSignatureBytes = (sigHex: string): Uint8Array | null => {
  try {
    if (!sigHex || typeof sigHex !== 'string') {
      return null;
    }
    return hexToBytes(sigHex);
  } catch (error) {
    console.error("Error converting signature hex to bytes:", error);
    return null;
  }
};

/**
 * Get public key bytes from hex string
 * @param pubKeyHex Public key hex string
 * @returns Uint8Array of public key bytes
 */
export const getPublicKeyBytes = (pubKeyHex: string): Uint8Array | null => {
  try {
    if (!pubKeyHex || typeof pubKeyHex !== 'string') {
      return null;
    }
    return hexToBytes(pubKeyHex);
  } catch (error) {
    console.error("Error converting public key hex to bytes:", error);
    return null;
  }
};
