
/**
 * Utilities for extracting signatures from SegWit witness data
 */
import { Signature } from '@/types';
import { bytesToHex } from '../../hexUtils';

/**
 * Extract signature using Bitcoin ECDSA parser
 * @param sigBytes Raw signature bytes
 * @returns Signature object or null
 */
export const extractSignatureWithBitcoinECDSA = (sigBytes: Uint8Array): Signature | null => {
  try {
    if (!window.Bitcoin || !window.Bitcoin.ECDSA) {
      return null;
    }
    
    // Use bitcoin library for DER signature parsing
    const sigData = window.Bitcoin.ECDSA.parseSig(sigBytes);
    
    // Extract r, s and sighash
    const r = sigData.r.toString(16).padStart(64, '0');
    const s = sigData.s.toString(16).padStart(64, '0');
    const sighashType = sigBytes[sigBytes.length - 1];
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    return {
      r,
      s,
      sighash: sighashHex
    };
  } catch (error) {
    console.error("Error using Bitcoin ECDSA parser:", error);
    return null;
  }
};

/**
 * Extract signature using manual DER parsing
 * @param sigBytes Raw signature bytes
 * @returns Signature object or null
 */
export const extractSignatureManually = (sigBytes: Uint8Array): Signature | null => {
  try {
    // Basic DER validation
    if (sigBytes[0] !== 0x30) {
      console.error("Invalid DER signature format: missing 0x30 header");
      return null;
    }
    
    // Extract r and s values manually from DER structure
    let pos = 1; // Skip 0x30 header
    const totalLen = sigBytes[pos];
    pos++;
    
    // First integer marker should be 0x02
    if (sigBytes[pos] !== 0x02) {
      console.error("Invalid DER signature: missing first integer marker");
      return null;
    }
    pos++;
    
    // Length of r value
    const rLen = sigBytes[pos];
    pos++;
    const rBytes = sigBytes.slice(pos, pos + rLen);
    pos += rLen;
    
    // Second integer marker should be 0x02
    if (sigBytes[pos] !== 0x02) {
      console.error("Invalid DER signature: missing second integer marker");
      return null;
    }
    pos++;
    
    // Length of s value
    const sLen = sigBytes[pos];
    pos++;
    const sBytes = sigBytes.slice(pos, pos + sLen);
    
    // Get sighash byte (last byte)
    const sighashType = sigBytes[sigBytes.length - 1];
    
    // Convert to hex
    const rHex = bytesToHex(rBytes).padStart(64, '0');
    const sHex = bytesToHex(sBytes).padStart(64, '0');
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    return {
      r: rHex,
      s: sHex,
      sighash: sighashHex
    };
  } catch (error) {
    console.error("Error in manual signature parsing:", error);
    return null;
  }
};

/**
 * Extract signature from witness data
 * @param sigBytes Signature bytes
 * @returns Parsed signature or null
 */
export const extractWitnessSignature = (sigBytes: Uint8Array): Signature | null => {
  // First try with Bitcoin ECDSA parser
  const bitcoinSig = extractSignatureWithBitcoinECDSA(sigBytes);
  if (bitcoinSig) return bitcoinSig;
  
  // Fall back to manual parsing
  return extractSignatureManually(sigBytes);
};
