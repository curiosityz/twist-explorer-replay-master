
/**
 * Utilities for extracting signatures from SegWit witness data
 */
import { Signature } from '@/types';
import { bytesToHex } from '../../hexUtils';
import { decodeDERSignature } from '@/lib/crypto/signatureUtils';

/**
 * Extract signature using Bitcoin ECDSA parser
 * @param sigBytes Raw signature bytes
 * @returns Signature object or null
 */
export const extractSignatureWithBitcoinECDSA = (sigBytes: Uint8Array): Signature | null => {
  try {
    if (!window.Bitcoin || !window.Bitcoin.ECDSA) {
      return null;
    }
    
    // Convert bytes to hex for Bitcoin library
    const sigHex = bytesToHex(sigBytes);
    console.log("Attempting to extract signature with Bitcoin.ECDSA:", sigHex);
    
    try {
      // Use bitcoin library for DER signature parsing
      const sigData = window.Bitcoin.ECDSA.parseSig(sigHex);
      
      // Extract r, s and sighash
      const r = sigData.r.toString(16).padStart(64, '0');
      const s = sigData.s.toString(16).padStart(64, '0');
      const sighashType = sigBytes[sigBytes.length - 1];
      const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
      
      return {
        r,
        s,
        sighash: sighashHex
      };
    } catch (parseError) {
      console.error("Bitcoin.ECDSA.parseSig failed:", parseError);
      return null;
    }
  } catch (error) {
    console.error("Error using Bitcoin ECDSA parser:", error);
    return null;
  }
};

/**
 * Extract signature using manual DER parsing
 * @param sigBytes Raw signature bytes
 * @returns Signature object or null
 */
export const extractSignatureManually = (sigBytes: Uint8Array): Signature | null => {
  try {
    console.log("Attempting manual signature extraction for bytes of length:", sigBytes.length);
    
    // Basic DER validation
    if (sigBytes[0] !== 0x30) {
      console.error("Invalid DER signature format: missing 0x30 header");
      return null;
    }
    
    // Extract r and s values manually from DER structure
    let pos = 1; // Skip 0x30 header
    const totalLen = sigBytes[pos];
    pos++;
    
    // First integer marker should be 0x02
    if (sigBytes[pos] !== 0x02) {
      console.error("Invalid DER signature: missing first integer marker");
      return null;
    }
    pos++;
    
    // Length of r value
    const rLen = sigBytes[pos];
    pos++;
    const rBytes = sigBytes.slice(pos, pos + rLen);
    pos += rLen;
    
    // Second integer marker should be 0x02
    if (sigBytes[pos] !== 0x02) {
      console.error("Invalid DER signature: missing second integer marker");
      return null;
    }
    pos++;
    
    // Length of s value
    const sLen = sigBytes[pos];
    pos++;
    const sBytes = sigBytes.slice(pos, pos + sLen);
    
    // Get sighash byte (last byte after DER structure)
    const sighashType = sigBytes[sigBytes.length - 1];
    
    // Convert to hex
    const rHex = bytesToHex(rBytes).padStart(64, '0');
    const sHex = bytesToHex(sBytes).padStart(64, '0');
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    console.log("Manual DER extraction result:", {
      r: rHex.substring(0, 10) + "...",
      s: sHex.substring(0, 10) + "...",
      sighash: sighashHex
    });
    
    return {
      r: rHex,
      s: sHex,
      sighash: sighashHex
    };
  } catch (error) {
    console.error("Error in manual signature parsing:", error);
    return null;
  }
};

/**
 * Extract signature using decodeDERSignature utility
 * @param sigBytes Signature bytes
 * @returns Parsed signature or null
 */
export const extractSignatureWithUtils = (sigBytes: Uint8Array): Signature | null => {
  try {
    // Convert to hex for utility function
    const sigHex = bytesToHex(sigBytes);
    console.log("Attempting to extract signature with utility function:", sigHex);
    
    try {
      // Use the decodeDERSignature utility
      const { r, s } = decodeDERSignature(sigHex);
      
      // Get sighash byte (last byte)
      const sighashType = sigBytes[sigBytes.length - 1];
      const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
      
      return { r, s, sighash: sighashHex };
    } catch (decodeError) {
      console.error("decodeDERSignature failed:", decodeError);
      return null;
    }
  } catch (error) {
    console.error("Error extracting signature with utility function:", error);
    return null;
  }
};

/**
 * Extract signature from witness data
 * @param sigBytes Signature bytes
 * @returns Parsed signature or null
 */
export const extractWitnessSignature = (sigBytes: Uint8Array): Signature | null => {
  console.log("Extracting witness signature from bytes of length:", sigBytes.length);
  
  // First try with Bitcoin ECDSA parser
  const bitcoinSig = extractSignatureWithBitcoinECDSA(sigBytes);
  if (bitcoinSig) {
    console.log("Successfully extracted signature with Bitcoin.ECDSA");
    return bitcoinSig;
  }
  
  // Next try with utility function
  const utilitySig = extractSignatureWithUtils(sigBytes);
  if (utilitySig) {
    console.log("Successfully extracted signature with utility function");
    return utilitySig;
  }
  
  // Fall back to manual parsing
  const manualSig = extractSignatureManually(sigBytes);
  if (manualSig) {
    console.log("Successfully extracted signature with manual parsing");
    return manualSig;
  }
  
  console.error("Failed to extract signature using any method");
  return null;
};
