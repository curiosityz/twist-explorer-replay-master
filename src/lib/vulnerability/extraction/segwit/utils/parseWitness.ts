
/**
 * Utilities for parsing SegWit witness data
 */
import { hexToBytes, bytesToHex } from '../../hexUtils';
import { checkBitcoinLibsLoaded } from '@/lib/crypto/bitcoin-libs/check-status';

/**
 * Extract the witness data array from a transaction
 * @param txData Transaction data from blockchain API
 * @returns Array of witness data or null if not found
 */
export const extractWitnessDataFromTx = (txData: any): string[] | null => {
  try {
    // Check if the transaction has inputs
    if (!txData || !txData.vin || !Array.isArray(txData.vin) || txData.vin.length === 0) {
      console.log("No inputs in transaction data");
      return null;
    }
    
    let witnessData = null;
    
    // Log transaction structure for debugging
    console.log("Transaction structure for witness extraction:", 
                JSON.stringify({
                  txid: txData.txid,
                  inputCount: txData.vin.length,
                  hasWitness: txData.vin.some((vin: any) => vin.witness || vin.txinwitness || vin.scriptWitness)
                }));
    
    // Find the first input with witness data
    for (let i = 0; i < txData.vin.length; i++) {
      const vin = txData.vin[i];
      // Different APIs use different property names for witness data
      let witnessArray = null;
      
      // Check all possible witness data field names
      if (vin.witness && Array.isArray(vin.witness) && vin.witness.length >= 2) {
        witnessArray = vin.witness;
        console.log(`Found witness data in 'witness' field in input #${i}:`, vin.witness);
      } else if (vin.txinwitness && Array.isArray(vin.txinwitness) && vin.txinwitness.length >= 2) {
        witnessArray = vin.txinwitness;
        console.log(`Found witness data in 'txinwitness' field in input #${i}:`, vin.txinwitness);
      } else if (vin.scriptWitness && Array.isArray(vin.scriptWitness) && vin.scriptWitness.length >= 2) {
        witnessArray = vin.scriptWitness;
        console.log(`Found witness data in 'scriptWitness' field in input #${i}:`, vin.scriptWitness);
      } else if (vin.witness && typeof vin.witness === 'string' && vin.witness.trim().length > 0) {
        // Some APIs provide witness data as a space-separated string
        try {
          const parts = vin.witness.trim().split(/\s+/);
          if (parts.length >= 2) {
            witnessArray = parts;
            console.log(`Found witness data as string in input #${i}:`, parts);
          }
        } catch (e) {
          console.log("Failed to parse witness string:", e);
        }
      } else if (vin.scriptSig && vin.scriptSig.hex && vin.scriptSig.hex.length > 0) {
        // Special case for native segwit (P2WPKH) where segwit is in scriptSig
        if (vin.scriptSig.hex.startsWith('16001')) {
          console.log(`Found potential P2WPKH scriptSig in input #${i}, checking further`, vin.scriptSig.hex);
          
          // If we have a matching witness somewhere else in the transaction
          if (txData.witness || txData.witnesses || txData.vin.some((v: any) => v.witness || v.txinwitness)) {
            // We'll handle this case elsewhere
            continue;
          }
        }
      }
      
      if (witnessArray) {
        witnessData = witnessArray;
        console.log(`Found witness data with length: ${witnessArray.length} in input #${i}`);
        break;
      }
    }
    
    // Look for witness data at the transaction level (some APIs put it there)
    if (!witnessData && txData.witness && Array.isArray(txData.witness) && txData.witness.length >= 2) {
      witnessData = txData.witness;
      console.log("Found witness data at transaction level:", txData.witness);
    }
    
    // Look for witnesses array (plural form used by some APIs)
    if (!witnessData && txData.witnesses && Array.isArray(txData.witnesses) && txData.witnesses.length > 0) {
      // Use the first non-empty witness array
      for (const witness of txData.witnesses) {
        if (Array.isArray(witness) && witness.length >= 2) {
          witnessData = witness;
          console.log("Found witness data in witnesses array:", witnessData);
          break;
        }
      }
    }
    
    // Check if we have witness data in other formats
    if (!witnessData && txData.hex && txData.hex.length > 0) {
      // Some APIs provide a transaction hex but don't parse the witness data
      console.log("No witness data found in standard fields, checking transaction hex");
      try {
        // If Bitcoin.js is available, try to extract witness from raw transaction
        if (window.Bitcoin && window.Bitcoin.Transaction) {
          const tx = window.Bitcoin.Transaction.fromHex(txData.hex);
          for (const input of tx.ins) {
            if (input.witness && input.witness.length >= 2) {
              witnessData = input.witness.map((w: any) => w.toString('hex'));
              console.log("Successfully extracted witness from transaction hex");
              break;
            }
          }
        }
      } catch (hexError) {
        console.error("Error extracting witness from transaction hex:", hexError);
      }
    }
    
    // Handle decoded JSON in case it's passed as a string
    if (!witnessData && txData.decoded_json) {
      try {
        const decoded = typeof txData.decoded_json === 'string' ? 
          JSON.parse(txData.decoded_json) : txData.decoded_json;
          
        if (decoded && decoded.vin && Array.isArray(decoded.vin)) {
          for (const vin of decoded.vin) {
            const witnessArray = vin.witness || vin.txinwitness || vin.scriptWitness;
            if (witnessArray && Array.isArray(witnessArray) && witnessArray.length >= 2) {
              witnessData = witnessArray;
              console.log("Found witness data in decoded_json with length:", witnessArray.length);
              break;
            }
          }
        }
      } catch (e) {
        console.error("Error parsing decoded_json:", e);
      }
    }
    
    return witnessData;
  } catch (error) {
    console.error("Error extracting witness data from transaction:", error);
    return null;
  }
};

/**
 * Parse witness data from a transaction input
 * @param witnessData Witness data array from transaction
 * @returns Object containing signature and public key hex, or null if invalid
 */
export const parseWitnessData = (witnessData: string[] | any[]): { sigHex: string, pubKeyHex: string } | null => {
  try {
    if (!witnessData || !Array.isArray(witnessData) || witnessData.length < 2) {
      console.log("Invalid witness data format");
      return null;
    }
    
    // Log witness data for debugging
    console.log("Witness data to parse:", witnessData);
    
    // In SegWit P2WPKH, the witness stack has two items:
    // [0] = Signature (with sighash byte)
    // [1] = Public key
    let sigHex = witnessData[0];
    let pubKeyHex = witnessData[1];
    
    // Handle different data types - some APIs return Buffer objects instead of strings
    if (typeof sigHex !== 'string') {
      if (sigHex.toString && typeof sigHex.toString === 'function') {
        // Try to convert Buffer to hex string
        sigHex = sigHex.toString('hex');
      } else if (sigHex.type === 'Buffer' && Array.isArray(sigHex.data)) {
        // Handle JSON-serialized Buffer objects
        sigHex = Buffer.from(sigHex.data).toString('hex');
      } else if (typeof sigHex === 'object') {
        // Try JSON stringification as last resort
        try {
          sigHex = JSON.stringify(sigHex);
        } catch (e) {
          console.error("Could not convert signature to string:", e);
        }
      }
    }
    
    if (typeof pubKeyHex !== 'string') {
      if (pubKeyHex.toString && typeof pubKeyHex.toString === 'function') {
        pubKeyHex = pubKeyHex.toString('hex');
      } else if (pubKeyHex.type === 'Buffer' && Array.isArray(pubKeyHex.data)) {
        pubKeyHex = Buffer.from(pubKeyHex.data).toString('hex');
      } else if (typeof pubKeyHex === 'object') {
        try {
          pubKeyHex = JSON.stringify(pubKeyHex);
        } catch (e) {
          console.error("Could not convert public key to string:", e);
        }
      }
    }
    
    // Remove '0x' prefix if present
    if (typeof sigHex === 'string' && sigHex.startsWith('0x')) {
      sigHex = sigHex.substring(2);
    }
    
    if (typeof pubKeyHex === 'string' && pubKeyHex.startsWith('0x')) {
      pubKeyHex = pubKeyHex.substring(2);
    }
    
    if (!sigHex || !pubKeyHex || typeof sigHex !== 'string' || typeof pubKeyHex !== 'string') {
      console.log("Invalid signature or public key in witness data");
      return null;
    }
    
    console.log("Successfully parsed witness data: sig length =", sigHex.length, 
                "pubKey length =", pubKeyHex.length);
    
    return { sigHex, pubKeyHex };
  } catch (error) {
    console.error("Error parsing witness data:", error);
    return null;
  }
};

/**
 * Get signature bytes from hex string
 * @param sigHex Signature hex string
 * @returns Uint8Array of signature bytes
 */
export const getSignatureBytes = (sigHex: string): Uint8Array | null => {
  try {
    if (!sigHex || typeof sigHex !== 'string') {
      return null;
    }
    
    const bytes = hexToBytes(sigHex);
    console.log("Converted signature hex to bytes, length:", bytes.length);
    return bytes;
  } catch (error) {
    console.error("Error converting signature hex to bytes:", error);
    return null;
  }
};

/**
 * Get public key bytes from hex string
 * @param pubKeyHex Public key hex string
 * @returns Uint8Array of public key bytes
 */
export const getPublicKeyBytes = (pubKeyHex: string): Uint8Array | null => {
  try {
    if (!pubKeyHex || typeof pubKeyHex !== 'string') {
      return null;
    }
    
    const bytes = hexToBytes(pubKeyHex);
    console.log("Converted public key hex to bytes, length:", bytes.length);
    return bytes;
  } catch (error) {
    console.error("Error converting public key hex to bytes:", error);
    return null;
  }
};
