
/**
 * Utilities for extracting public keys from SegWit witness data
 */
import { CryptographicPoint } from '@/types';
import { bytesToHex } from '../../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';

/**
 * Extract uncompressed public key
 * @param pubKeyBytes Public key bytes (uncompressed format)
 * @returns Public key point or null
 */
export const extractUncompressedPublicKey = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  try {
    if (pubKeyBytes[0] !== 0x04 || pubKeyBytes.length !== 65) {
      console.log("Not an uncompressed public key format (should start with 0x04 and be 65 bytes)");
      return null;
    }
    
    const xBytes = pubKeyBytes.slice(1, 33);
    const yBytes = pubKeyBytes.slice(33, 65);
    
    return {
      x: bytesToHex(xBytes),
      y: bytesToHex(yBytes),
      isOnCurve: true
    };
  } catch (error) {
    console.error("Error extracting uncompressed public key:", error);
    return null;
  }
};

/**
 * Extract compressed public key using secp256k1 library
 * @param pubKeyBytes Public key bytes (compressed format)
 * @returns Public key point or null
 */
export const extractCompressedPublicKeyWithSecp = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  try {
    if ((pubKeyBytes[0] !== 0x02 && pubKeyBytes[0] !== 0x03) || pubKeyBytes.length !== 33) {
      console.log("Not a compressed public key format (should start with 0x02/0x03 and be 33 bytes)");
      return null;
    }
    
    if (!window.secp256k1) {
      console.log("secp256k1 library not available");
      return null;
    }
    
    console.log("Decompressing public key with secp256k1");
    
    try {
      // Check which method is available for decompression in the secp256k1 library
      // Different implementations may have different method names
      let decompressedBytes: Uint8Array | null = null;
      
      if (typeof window.secp256k1.publicKeyConvert === 'function') {
        // Try the standard publicKeyConvert method
        decompressedBytes = window.secp256k1.publicKeyConvert(pubKeyBytes, false);
      } else if (typeof window.secp256k1.decompress === 'function') {
        // Try the decompress method (some implementations use this)
        decompressedBytes = window.secp256k1.decompress(pubKeyBytes);
      } else if (window.secp256k1.utils && typeof window.secp256k1.utils.pointDecompress === 'function') {
        // Try the utils.pointDecompress method (noble-secp256k1 uses this)
        decompressedBytes = window.secp256k1.utils.pointDecompress(pubKeyBytes);
      } else if (window.secp256k1.Point && typeof window.secp256k1.Point.fromHex === 'function') {
        // Try the Point.fromHex method (noble-secp256k1 also might use this)
        const point = window.secp256k1.Point.fromHex(pubKeyBytes);
        if (point && point.x && point.y) {
          // Create our own decompressed format
          decompressedBytes = new Uint8Array(65);
          decompressedBytes[0] = 0x04; // Uncompressed format prefix
          
          // Convert the x and y coordinates to bytes and copy them
          const xBytes = hexToUint8Array(point.x.toString(16).padStart(64, '0'));
          const yBytes = hexToUint8Array(point.y.toString(16).padStart(64, '0'));
          
          decompressedBytes.set(xBytes, 1);
          decompressedBytes.set(yBytes, 33);
        }
      }
      
      if (decompressedBytes && decompressedBytes.length === 65) {
        const xBytes = decompressedBytes.slice(1, 33);
        const yBytes = decompressedBytes.slice(33, 65);
        
        return {
          x: bytesToHex(xBytes),
          y: bytesToHex(yBytes),
          isOnCurve: true
        };
      } else {
        console.log("Failed to decompress using secp256k1 methods");
      }
    } catch (e) {
      console.error("secp256k1 decompression failed:", e);
    }
    
    return null;
  } catch (error) {
    console.error("Error decompressing public key with secp256k1:", error);
    return null;
  }
};

/**
 * Helper function to convert hex string to Uint8Array
 */
function hexToUint8Array(hex: string): Uint8Array {
  if (hex.startsWith('0x')) hex = hex.substring(2);
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(hex.substring(i * 2, i * 2 + 2), 16);
  }
  return bytes;
}

/**
 * Extract public key using utility function
 * @param pubKeyHex Public key hex string
 * @returns Public key point or null
 */
export const extractCompressedPublicKeyWithUtil = (pubKeyHex: string): CryptographicPoint | null => {
  try {
    console.log("Decompressing public key with utility function");
    
    // Clean the hex string if needed
    const cleanHex = pubKeyHex.startsWith('0x') ? pubKeyHex.substring(2) : pubKeyHex;
    
    // Validate format (02/03 prefix for compressed keys)
    if (cleanHex.length !== 66 || (cleanHex[0] !== '0' && cleanHex[1] !== '2' && cleanHex[1] !== '3')) {
      console.log("Invalid compressed public key format in hex");
      return null;
    }
    
    try {
      const decomp = decompressPublicKey(cleanHex);
      
      // If coordinates are returned as hex with 0x prefix, remove it
      const x = decomp.x.startsWith('0x') ? decomp.x.substring(2) : decomp.x;
      const y = decomp.y.startsWith('0x') ? decomp.y.substring(2) : decomp.y;
      
      return {
        x,
        y,
        isOnCurve: decomp.isOnCurve
      };
    } catch (e) {
      console.error("Utility decompression failed:", e);
      return null;
    }
  } catch (error) {
    console.error("Error decompressing public key with utility function:", error);
    return null;
  }
};

/**
 * Manual decompression of public key on secp256k1 curve
 * @param pubKeyHex Compressed public key hex
 * @returns Decompressed point or null
 */
export const decompressPublicKeyManually = (pubKeyHex: string): CryptographicPoint | null => {
  try {
    console.log("Attempting manual decompression of public key");
    
    // Remove 0x prefix if exists
    const cleanHex = pubKeyHex.startsWith('0x') ? pubKeyHex.substring(2) : pubKeyHex;
    
    // Check if it's a compressed key
    if (cleanHex.length !== 66 || (cleanHex[0] !== '0' || (cleanHex[1] !== '2' && cleanHex[1] !== '3'))) {
      console.error("Invalid compressed public key format");
      return null;
    }
    
    // Get X coordinate
    const x = cleanHex.substring(2);
    
    // Extract Y parity from first byte (02 = even, 03 = odd)
    const isYOdd = cleanHex.substring(0, 2) === '03';
    
    // Here we would implement the full math to recover Y from X and the parity bit
    // This is complex and involves solving the curve equation y² = x³ + 7 (mod p)
    // For now, we'll rely on the utility functions and secp256k1
    
    console.error("Manual decompression not fully implemented");
    return null;
  } catch (error) {
    console.error("Error in manual public key decompression:", error);
    return null;
  }
};

/**
 * Extract public key from witness data
 * @param pubKeyBytes Public key bytes 
 * @returns Public key point or null
 */
export const extractWitnessPublicKey = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  console.log("Extracting witness public key, bytes length:", pubKeyBytes.length);
  
  // Try uncompressed format first
  const uncompressed = extractUncompressedPublicKey(pubKeyBytes);
  if (uncompressed) {
    console.log("Successfully extracted uncompressed public key");
    return uncompressed;
  }
  
  // Try compressed format with secp256k1
  const secp = extractCompressedPublicKeyWithSecp(pubKeyBytes);
  if (secp) {
    console.log("Successfully extracted public key with secp256k1");
    return secp;
  }
  
  // Fallback to utility function
  const pubKeyHex = bytesToHex(pubKeyBytes);
  const util = extractCompressedPublicKeyWithUtil(pubKeyHex);
  if (util) {
    console.log("Successfully extracted public key with utility function");
    return util;
  }
  
  console.error("Failed to extract public key using any method");
  return null;
};
