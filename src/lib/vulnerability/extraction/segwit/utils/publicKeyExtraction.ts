
/**
 * Utilities for extracting public keys from SegWit witness data
 */
import { CryptographicPoint } from '@/types';
import { bytesToHex } from '../../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';

/**
 * Extract uncompressed public key
 * @param pubKeyBytes Public key bytes (uncompressed format)
 * @returns Public key point or null
 */
export const extractUncompressedPublicKey = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  try {
    if (pubKeyBytes[0] !== 0x04 || pubKeyBytes.length !== 65) {
      console.log("Not an uncompressed public key format (should start with 0x04 and be 65 bytes)");
      return null;
    }
    
    const xBytes = pubKeyBytes.slice(1, 33);
    const yBytes = pubKeyBytes.slice(33, 65);
    
    return {
      x: bytesToHex(xBytes),
      y: bytesToHex(yBytes),
      isOnCurve: true
    };
  } catch (error) {
    console.error("Error extracting uncompressed public key:", error);
    return null;
  }
};

/**
 * Extract compressed public key using secp256k1 library
 * @param pubKeyBytes Public key bytes (compressed format)
 * @returns Public key point or null
 */
export const extractCompressedPublicKeyWithSecp = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  try {
    if ((pubKeyBytes[0] !== 0x02 && pubKeyBytes[0] !== 0x03) || pubKeyBytes.length !== 33) {
      console.log("Not a compressed public key format (should start with 0x02/0x03 and be 33 bytes)");
      return null;
    }
    
    if (!window.secp256k1) {
      console.log("secp256k1 library not available");
      return null;
    }
    
    console.log("Decompressing public key with secp256k1");
    
    try {
      // Use publicKeyConvert for public key decompression
      const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes, false);
      
      if (decompressed && decompressed.length === 65) {
        const xBytes = decompressed.slice(1, 33);
        const yBytes = decompressed.slice(33, 65);
        
        return {
          x: bytesToHex(xBytes),
          y: bytesToHex(yBytes),
          isOnCurve: true
        };
      }
    } catch (e) {
      console.error("secp256k1 decompression failed:", e);
    }
    
    return null;
  } catch (error) {
    console.error("Error decompressing public key with secp256k1:", error);
    return null;
  }
};

/**
 * Extract public key using utility function
 * @param pubKeyHex Public key hex string
 * @returns Public key point or null
 */
export const extractCompressedPublicKeyWithUtil = (pubKeyHex: string): CryptographicPoint | null => {
  try {
    console.log("Decompressing public key with utility function");
    
    // Clean the hex string if needed
    const cleanHex = pubKeyHex.startsWith('0x') ? pubKeyHex.substring(2) : pubKeyHex;
    
    // Validate format (02/03 prefix for compressed keys)
    if (cleanHex.length !== 66 || (cleanHex[0] !== '0' && cleanHex[1] !== '2' && cleanHex[1] !== '3')) {
      console.log("Invalid compressed public key format in hex");
      return null;
    }
    
    try {
      const decomp = decompressPublicKey(cleanHex);
      
      // If coordinates are returned as hex with 0x prefix, remove it
      const x = decomp.x.startsWith('0x') ? decomp.x.substring(2) : decomp.x;
      const y = decomp.y.startsWith('0x') ? decomp.y.substring(2) : decomp.y;
      
      return {
        x,
        y,
        isOnCurve: decomp.isOnCurve
      };
    } catch (e) {
      console.error("Utility decompression failed:", e);
      return null;
    }
  } catch (error) {
    console.error("Error decompressing public key with utility:", error);
    return null;
  }
};

/**
 * Manual decompression of public key on secp256k1 curve
 * @param pubKeyHex Compressed public key hex
 * @returns Decompressed point or null
 */
export const decompressPublicKeyManually = (pubKeyHex: string): CryptographicPoint | null => {
  try {
    console.log("Attempting manual decompression of public key");
    
    // Remove 0x prefix if exists
    const cleanHex = pubKeyHex.startsWith('0x') ? pubKeyHex.substring(2) : pubKeyHex;
    
    // Check if it's a compressed key
    if (cleanHex.length !== 66 || (cleanHex[0] !== '0' || (cleanHex[1] !== '2' && cleanHex[1] !== '3'))) {
      console.error("Invalid compressed public key format");
      return null;
    }
    
    // Get X coordinate
    const x = cleanHex.substring(2);
    
    // Extract Y parity from first byte (02 = even, 03 = odd)
    const isYOdd = cleanHex.substring(0, 2) === '03';
    
    // Here we would implement the full math to recover Y from X and the parity bit
    // This is complex and involves solving the curve equation y² = x³ + 7 (mod p)
    // For now, we'll rely on the utility functions and secp256k1
    
    console.error("Manual decompression not fully implemented");
    return null;
  } catch (error) {
    console.error("Error in manual public key decompression:", error);
    return null;
  }
};

/**
 * Extract public key from witness data
 * @param pubKeyBytes Public key bytes 
 * @returns Public key point or null
 */
export const extractWitnessPublicKey = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  console.log("Extracting witness public key, bytes length:", pubKeyBytes.length);
  
  // Try uncompressed format first
  const uncompressed = extractUncompressedPublicKey(pubKeyBytes);
  if (uncompressed) {
    console.log("Successfully extracted uncompressed public key");
    return uncompressed;
  }
  
  // Try compressed format with secp256k1
  const secp = extractCompressedPublicKeyWithSecp(pubKeyBytes);
  if (secp) {
    console.log("Successfully extracted public key with secp256k1");
    return secp;
  }
  
  // Fallback to utility function
  const pubKeyHex = bytesToHex(pubKeyBytes);
  const util = extractCompressedPublicKeyWithUtil(pubKeyHex);
  if (util) {
    console.log("Successfully extracted public key with utility function");
    return util;
  }
  
  console.error("Failed to extract public key using any method");
  return null;
};
