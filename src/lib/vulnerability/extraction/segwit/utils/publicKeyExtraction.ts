
import { CryptographicPoint } from '@/types';
import { bytesToHex } from '../../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';
import { isPointOnSecp256k1Curve } from '@/lib/crypto/publicKeyUtils/isPointOnCurve';

/**
 * Extract public key from witness script
 * @param pubKeyBytes Raw public key bytes
 * @returns Extracted public key point or null if extraction fails
 */
export const extractPublicKeyFromWitness = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  try {
    if (!pubKeyBytes || pubKeyBytes.length === 0) {
      console.log("Empty witness public key bytes");
      return null;
    }
    
    console.log("Extracting witness public key, bytes length:", pubKeyBytes.length);
    
    // Handle different public key formats
    if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
      // Uncompressed key (04 + x + y)
      console.log("Found uncompressed public key format (0x04)");
      const xBytes = pubKeyBytes.slice(1, 33);
      const yBytes = pubKeyBytes.slice(33, 65);
      
      const xHex = bytesToHex(xBytes);
      const yHex = bytesToHex(yBytes);
      
      // Check if the point is on the curve
      const isOnCurve = isPointOnSecp256k1Curve(xHex, yHex);
      
      const publicKey: CryptographicPoint = {
        x: xHex,
        y: yHex,
        isOnCurve
      };
      
      console.log("Extracted uncompressed public key from witness:", 
        "x:", publicKey.x.substring(0, 10) + "...", 
        "y:", publicKey.y.substring(0, 10) + "...",
        "isOnCurve:", publicKey.isOnCurve);
        
      return publicKey;
    }
    else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
      // Compressed key (02/03 + x)
      console.log("Not an uncompressed public key format (should start with 0x04 and be 65 bytes)");
      console.log("Decompressing public key with secp256k1");
      
      try {
        const pubKeyHex = bytesToHex(pubKeyBytes);
        
        // Use secp256k1 library directly to decompress the key if available
        if (window.secp256k1) {
          try {
            const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
            
            // Extract x and y coordinates (format: 04 | x | y)
            const xBytes = decompressed.slice(1, 33);
            const yBytes = decompressed.slice(33, 65);
            
            const xHex = bytesToHex(xBytes);
            const yHex = bytesToHex(yBytes);
            
            // Check if the point is on the curve
            const isOnCurve = isPointOnSecp256k1Curve(xHex, yHex);
            
            const publicKey: CryptographicPoint = {
              x: xHex,
              y: yHex,
              isOnCurve
            };
            
            return publicKey;
          } catch (secp256k1Error) {
            console.log("Failed to decompress using secp256k1 methods");
            // Fall back to utility function
          }
        }
        
        // Fall back to our utility function if secp256k1 isn't available or failed
        console.log("Decompressing public key with utility function");
        const decomp = decompressPublicKey(pubKeyHex);
        
        if (!decomp) {
          console.error("Failed to decompress public key");
          return null;
        }
        
        console.log("Successfully extracted public key with utility function");
        
        const publicKey: CryptographicPoint = {
          x: decomp.x,
          y: decomp.y,
          isOnCurve: decomp.isOnCurve
        };
        
        return publicKey;
      } catch (decompError) {
        console.error("Error decompressing public key:", decompError);
        return null;
      }
    } else {
      console.log("Invalid public key format in witness. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
      return null;
    }
  } catch (error) {
    console.error("Error extracting public key from witness:", error);
    return null;
  }
};

/**
 * Extract public key from P2WPKH or P2WSH output script
 * @param outputScript Raw output script
 * @returns Extracted public key or null if not found
 */
export const extractPublicKeyFromWitnessScript = (outputScript: Uint8Array): CryptographicPoint | null => {
  try {
    // Check for valid witness program length
    if (!outputScript || outputScript.length < 4) {
      return null;
    }
    
    // Check for witness version and witness program format
    if (outputScript[0] !== 0x00 && outputScript[0] !== 0x00 + 0x50) {
      return null;
    }
    
    // Get the length of the witness program
    const programLength = outputScript[1];
    
    // Check program length for P2WPKH (20 bytes) or P2WSH (32 bytes)
    if (programLength !== 20 && programLength !== 32) {
      return null;
    }
    
    // Extract the witness program
    const witnessProgram = outputScript.slice(2, 2 + programLength);
    
    // For P2WPKH, the witness program is a public key hash
    // We can't directly extract the public key from just the hash
    
    console.log(`Found witness program of length ${programLength}, 
                 but cannot directly extract public key from script only`);
    
    return null;
  } catch (error) {
    console.error("Error extracting public key from witness script:", error);
    return null;
  }
};

// Make sure to export this function which is being imported by other files
export { extractPublicKeyFromWitness as extractWitnessPublicKey };
