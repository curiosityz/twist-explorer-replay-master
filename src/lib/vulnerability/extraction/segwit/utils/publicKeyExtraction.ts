
import { CryptographicPoint } from '@/types';
import { bytesToHex } from '../../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';

/**
 * Extract public key from witness script
 * @param pubKeyBytes Raw public key bytes
 * @returns Extracted public key point or null if extraction fails
 */
export const extractPublicKeyFromWitness = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  try {
    if (!pubKeyBytes || pubKeyBytes.length === 0) {
      console.log("Empty witness public key bytes");
      return null;
    }
    
    // Handle different public key formats
    if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
      // Uncompressed key (04 + x + y)
      const xBytes = pubKeyBytes.slice(1, 33);
      const yBytes = pubKeyBytes.slice(33, 65);
      
      const xHex = bytesToHex(xBytes);
      const yHex = bytesToHex(yBytes);
      
      const publicKey: CryptographicPoint = {
        x: xHex,
        y: yHex
      };
      
      console.log("Extracted uncompressed public key from witness:", 
        "x:", publicKey.x.substring(0, 10) + "...", 
        "y:", publicKey.y.substring(0, 10) + "...");
        
      return publicKey;
    }
    else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
      // Compressed key (02/03 + x)
      try {
        const pubKeyHex = bytesToHex(pubKeyBytes);
        
        // Use secp256k1 library directly to decompress the key if available
        if (window.secp256k1) {
          const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
          
          // Extract x and y coordinates (format: 04 | x | y)
          const xBytes = decompressed.slice(1, 33);
          const yBytes = decompressed.slice(33, 65);
          
          const xHex = bytesToHex(xBytes);
          const yHex = bytesToHex(yBytes);
          
          const publicKey: CryptographicPoint = {
            x: xHex,
            y: yHex
          };
          
          return publicKey;
        } else {
          // Fall back to our utility function if secp256k1 isn't available
          const decomp = decompressPublicKey(pubKeyHex);
          
          if (!decomp) {
            console.error("Failed to decompress public key");
            return null;
          }
          
          const publicKey: CryptographicPoint = {
            x: decomp.x,
            y: decomp.y
          };
          
          return publicKey;
        }
      } catch (decompError) {
        console.error("Error decompressing public key:", decompError);
        return null;
      }
    } else {
      console.log("Invalid public key format in witness. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
      return null;
    }
  } catch (error) {
    console.error("Error extracting public key from witness:", error);
    return null;
  }
};

/**
 * Extract public key from P2WPKH or P2WSH output script
 * @param outputScript Raw output script
 * @returns Extracted public key or null if not found
 */
export const extractPublicKeyFromWitnessScript = (outputScript: Uint8Array): CryptographicPoint | null => {
  try {
    // Check for valid witness program length
    if (!outputScript || outputScript.length < 4) {
      return null;
    }
    
    // Check for witness version and witness program format
    if (outputScript[0] !== 0x00 && outputScript[0] !== 0x00 + 0x50) {
      return null;
    }
    
    // Get the length of the witness program
    const programLength = outputScript[1];
    
    // Check program length for P2WPKH (20 bytes) or P2WSH (32 bytes)
    if (programLength !== 20 && programLength !== 32) {
      return null;
    }
    
    // Extract the witness program
    const witnessProgram = outputScript.slice(2, 2 + programLength);
    
    // For P2WPKH, the witness program is a public key hash
    // We can't directly extract the public key from just the hash
    
    // For P2WSH with known redeem script containing a public key,
    // we would need the witness stack to extract the public key
    
    // This function would need additional data (like witness stack)
    // to actually extract a public key
    
    console.log(`Found witness program of length ${programLength}, 
                 but cannot directly extract public key from script only`);
    
    return null;
  } catch (error) {
    console.error("Error extracting public key from witness script:", error);
    return null;
  }
};
