
/**
 * Utilities for extracting public keys from SegWit witness data
 */
import { CryptographicPoint } from '@/types';
import { bytesToHex } from '../../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';

/**
 * Extract uncompressed public key
 * @param pubKeyBytes Public key bytes (uncompressed format)
 * @returns Public key point or null
 */
export const extractUncompressedPublicKey = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  try {
    if (pubKeyBytes[0] !== 0x04 || pubKeyBytes.length !== 65) {
      return null;
    }
    
    const xBytes = pubKeyBytes.slice(1, 33);
    const yBytes = pubKeyBytes.slice(33, 65);
    
    return {
      x: bytesToHex(xBytes),
      y: bytesToHex(yBytes),
      isOnCurve: true
    };
  } catch (error) {
    console.error("Error extracting uncompressed public key:", error);
    return null;
  }
};

/**
 * Extract compressed public key using secp256k1 library
 * @param pubKeyBytes Public key bytes (compressed format)
 * @returns Public key point or null
 */
export const extractCompressedPublicKeyWithSecp = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  try {
    if ((pubKeyBytes[0] !== 0x02 && pubKeyBytes[0] !== 0x03) || pubKeyBytes.length !== 33) {
      return null;
    }
    
    if (!window.secp256k1) {
      return null;
    }
    
    const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
    
    const xBytes = decompressed.slice(1, 33);
    const yBytes = decompressed.slice(33, 65);
    
    return {
      x: bytesToHex(xBytes),
      y: bytesToHex(yBytes),
      isOnCurve: true
    };
  } catch (error) {
    console.error("Error decompressing public key with secp256k1:", error);
    return null;
  }
};

/**
 * Extract public key using utility function
 * @param pubKeyHex Public key hex string
 * @returns Public key point or null
 */
export const extractCompressedPublicKeyWithUtil = (pubKeyHex: string): CryptographicPoint | null => {
  try {
    const decomp = decompressPublicKey(pubKeyHex);
    
    return {
      x: decomp.x,
      y: decomp.y,
      isOnCurve: decomp.isOnCurve
    };
  } catch (error) {
    console.error("Error decompressing public key with utility:", error);
    return null;
  }
};

/**
 * Extract public key from witness data
 * @param pubKeyBytes Public key bytes 
 * @returns Public key point or null
 */
export const extractWitnessPublicKey = (pubKeyBytes: Uint8Array): CryptographicPoint | null => {
  // Try uncompressed format first
  const uncompressed = extractUncompressedPublicKey(pubKeyBytes);
  if (uncompressed) return uncompressed;
  
  // Try compressed format with secp256k1
  const secp = extractCompressedPublicKeyWithSecp(pubKeyBytes);
  if (secp) return secp;
  
  // Fallback to utility function
  const pubKeyHex = bytesToHex(pubKeyBytes);
  return extractCompressedPublicKeyWithUtil(pubKeyHex);
};
