
/**
 * Core functionality for extracting cryptographic data from SegWit transactions
 */

import { Signature, CryptographicPoint } from '@/types';
import { extractWitnessDataFromTx, parseWitnessData, getSignatureBytes, getPublicKeyBytes } from './utils/parseWitness';
import { extractWitnessSignature } from './utils/signatureExtraction';
import { extractWitnessPublicKey } from './utils/publicKeyExtraction';

/**
 * Structure for cryptographic data
 */
interface CryptographicData {
  signature: Signature;
  publicKey: CryptographicPoint;
  rawSignature: string;
  rawPublicKey: string;
  transactionFormat: string;
}

/**
 * Extract cryptographic data from SegWit transaction
 * @param txData Transaction data
 * @returns CryptographicData with signature and public key, or null if extraction fails
 */
export const extractSegWitData = (txData: any): CryptographicData | null => {
  try {
    console.log("Starting SegWit data extraction");
    
    // Additional logging to help debug the transaction structure
    const txStructure = {
      txid: txData?.txid || txData?.hash,
      inputCount: txData?.vin?.length || 0,
      hasWitness: hasWitnessData(txData)
    };
    console.log("Transaction structure for witness extraction:", txStructure);
    
    // Check if transaction has inputs with witness data
    if (!txData || !txData.vin || !Array.isArray(txData.vin) || txData.vin.length === 0) {
      console.error("No valid transaction inputs found");
      return null;
    }
    
    // Log the number of inputs for debugging
    console.log(txData.vin.length);
    
    // Try to extract witness data from any input that has it
    let witnessData = null;
    let witnessInput = null;
    
    // First pass: check for direct witness data fields
    for (let i = 0; i < txData.vin.length; i++) {
      const input = txData.vin[i];
      
      // Check for witness fields using different possible field names
      if (input.witness && Array.isArray(input.witness) && input.witness.length >= 2) {
        witnessData = input.witness;
        witnessInput = i;
        console.log(`Found witness data in input #${i} using 'witness' field`);
        break;
      }
      
      if (input.txinwitness && Array.isArray(input.txinwitness) && input.txinwitness.length >= 2) {
        witnessData = input.txinwitness;
        witnessInput = i;
        console.log(`Found witness data in input #${i} using 'txinwitness' field`);
        break;
      }
      
      // Check for Blockchair API format
      if (input.witness_hex && typeof input.witness_hex === 'string' && input.witness_hex.length > 0) {
        try {
          // Parse from hex string
          const witnessHex = input.witness_hex;
          // Split by opcode 0x02 (length prefix) as rough heuristic
          const parts = witnessHex.match(/.{1,144}/g);
          if (parts && parts.length >= 2) {
            witnessData = parts;
            witnessInput = i;
            console.log(`Found witness data in input #${i} from witness_hex field`);
            break;
          }
        } catch (e) {
          console.log("Could not parse witness_hex string", e);
        }
      }
      
      // Handle blockchain.info API format that uses flat 'witness' field
      if (input.witness && typeof input.witness === 'string' && input.witness.length > 0) {
        // Try to parse from the string format
        try {
          const parts = input.witness.split(' ');
          if (parts.length >= 2) {
            witnessData = parts;
            witnessInput = i;
            console.log(`Found witness data in input #${i} from string format`);
            break;
          }
        } catch (e) {
          console.log("Could not parse witness string", e);
        }
      }
    }
    
    // Second pass: Check for scriptSig that might contain witness program
    if (!witnessData) {
      for (let i = 0; i < txData.vin.length; i++) {
        const input = txData.vin[i];
        
        if (input.scriptSig && input.scriptSig.hex) {
          console.log("Found scriptSig.hex, checking if it contains witness data");
          
          // Check for witness program pattern (0x0014 followed by 20 bytes)
          const scriptHex = input.scriptSig.hex;
          if (scriptHex.startsWith('160014') || scriptHex.startsWith('220020')) {
            // This is likely a P2SH-P2WPKH or P2SH-P2WSH
            // We need to look at the redeem script
            // For scanner purposes, just identify this as a potential segwit transaction
            console.log("Found potential witness program in scriptSig");
          }
        }
      }
    }
    
    if (!witnessData) {
      console.error("No witness data found in any transaction input");
      return null;
    }
    
    console.log(`Using witness data from input #${witnessInput}:`, witnessData);
    
    // Parse signature and public key from witness data
    const parsedData = parseWitnessData(witnessData);
    if (!parsedData) {
      console.error("Failed to parse witness data");
      return null;
    }
    
    console.log("Successfully parsed witness data");
    
    // Extract bytes from hex strings
    const sigBytes = getSignatureBytes(parsedData.sigHex);
    const pubKeyBytes = getPublicKeyBytes(parsedData.pubKeyHex);
    
    if (!sigBytes || !pubKeyBytes) {
      console.error("Failed to convert hex to bytes");
      return null;
    }
    
    console.log("Successfully converted signature and pubkey to bytes");
    
    // Extract signature data
    const signature = extractWitnessSignature(sigBytes);
    if (!signature) {
      console.error("Failed to extract witness signature");
      return null;
    }
    
    // Extract public key data
    const publicKey = extractWitnessPublicKey(pubKeyBytes);
    if (!publicKey) {
      console.error("Failed to extract witness public key");
      return null;
    }
    
    console.log("Successfully extracted SegWit cryptographic data:", {
      signature: { r: signature.r.substring(0, 10) + '...', s: signature.s.substring(0, 10) + '...' },
      publicKey: { x: publicKey.x.substring(0, 10) + '...', y: publicKey.y.substring(0, 10) + '...' }
    });
    
    // Return the extracted data
    return {
      signature,
      publicKey,
      rawSignature: parsedData.sigHex,
      rawPublicKey: parsedData.pubKeyHex,
      transactionFormat: 'segwit'
    };
  } catch (error) {
    console.error("Error in SegWit data extraction:", error);
    return null;
  }
};

/**
 * Check if transaction has any witness data
 * @param txData Transaction data
 * @returns Boolean indicating if witness data exists
 */
function hasWitnessData(txData: any): boolean {
  if (!txData || !txData.vin || !Array.isArray(txData.vin) || txData.vin.length === 0) {
    return false;
  }
  
  for (const input of txData.vin) {
    if (input.witness && Array.isArray(input.witness) && input.witness.length > 0) return true;
    if (input.txinwitness && Array.isArray(input.txinwitness) && input.txinwitness.length > 0) return true;
    if (input.witness && typeof input.witness === 'string' && input.witness.length > 0) return true;
    if (input.witness_hex && typeof input.witness_hex === 'string' && input.witness_hex.length > 0) return true;
  }
  
  return false;
}
