
import { parseWitnessData } from './utils/parseWitness';
import { extractWitnessPublicKey } from './utils/publicKeyExtraction';
import { extractWitnessSignature } from './utils/signatureExtraction';
import { PublicKey } from '@/types/publicKey';

/**
 * Extract cryptographic data from SegWit transactions
 * @param txData Transaction data from blockchain API
 * @returns Object containing public key and signature data, or null if unsuccessful
 */
export const extractSegWitData = (txData: any) => {
  try {
    console.log("Starting SegWit data extraction");
    
    if (!txData || !txData.vin || !Array.isArray(txData.vin) || txData.vin.length === 0) {
      console.error("Invalid transaction data structure for SegWit extraction");
      return null;
    }
    
    // Log transaction structure to help with debugging
    console.log("Transaction structure for witness extraction:", {
      txid: txData.txid || "unknown",
      inputCount: txData.vin.length,
      hasWitness: true
    });
    
    // Check each input for witness data
    for (let i = 0; i < txData.vin.length; i++) {
      const input = txData.vin[i];
      console.log(txData.vin.length);
      
      // Check for various witness field names used by different APIs
      const witnessData = input.witness || input.txinwitness || input.scriptWitness;
      
      // If we found witness data, try to extract public key and signature
      if (witnessData) {
        const parsedWitness = parseWitnessData(witnessData);
        
        if (parsedWitness) {
          // Try to extract public key
          const publicKey = extractWitnessPublicKey(
            parsedWitness.pubKeyHex ? 
              new Uint8Array(Buffer.from(parsedWitness.pubKeyHex, 'hex')) :
              new Uint8Array()
          );
          
          // Try to extract signature 
          const signature = extractWitnessSignature(
            parsedWitness.sigHex ?
              new Uint8Array(Buffer.from(parsedWitness.sigHex, 'hex')) :
              new Uint8Array()
          );
          
          if (publicKey && signature) {
            return {
              publicKey: publicKey as PublicKey,
              signature: signature
            };
          }
        }
      } else if (input.scriptSig && input.scriptSig.hex) {
        // For some P2SH-wrapped SegWit inputs, the witness data might be in scriptSig
        console.log("Found scriptSig.hex, checking if it contains witness data");
        
        // Look for characteristic patterns of SegWit in scriptSig
        const scriptHex = input.scriptSig.hex;
        
        // P2SH-wrapped P2WPKH starts with 16 0014 followed by a 20-byte hash
        if (scriptHex.startsWith('160014') && scriptHex.length >= 46) {
          // This is likely a P2SH-wrapped SegWit transaction
          // Try next input as this one doesn't have the actual witness data
          continue;
        }
      }
    }
    
    // If we get here, we couldn't find usable witness data
    console.error("No witness data found in transaction");
    return null;
  } catch (error) {
    console.error("Error extracting SegWit data:", error);
    return null;
  }
};
