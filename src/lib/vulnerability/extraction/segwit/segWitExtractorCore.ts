
/**
 * Core functionality for extracting cryptographic data from SegWit transactions
 */

import { Signature, CryptographicPoint } from '@/types';
import { extractWitnessDataFromTx, parseWitnessData, getSignatureBytes, getPublicKeyBytes } from './utils/parseWitness';
import { extractWitnessSignature } from './utils/signatureExtraction';
import { extractWitnessPublicKey } from './utils/publicKeyExtraction';

/**
 * Structure for cryptographic data
 */
interface CryptographicData {
  signature: Signature;
  publicKey: CryptographicPoint;
  rawSignature: string;
  rawPublicKey: string;
  transactionFormat: string;
}

/**
 * Extract cryptographic data from SegWit transaction
 * @param txData Transaction data
 * @returns CryptographicData with signature and public key, or null if extraction fails
 */
export const extractSegWitData = (txData: any): CryptographicData | null => {
  try {
    console.log("Starting SegWit data extraction");
    
    // Check if transaction has inputs with witness data
    if (!txData || !txData.vin || !Array.isArray(txData.vin) || txData.vin.length === 0) {
      console.error("No valid transaction inputs found");
      return null;
    }
    
    // Log the number of inputs for debugging
    console.log(`Transaction has ${txData.vin.length} inputs`);
    
    // Try to extract witness data from any input that has it
    let witnessData = null;
    let witnessInput = null;
    
    for (let i = 0; i < txData.vin.length; i++) {
      const input = txData.vin[i];
      
      // Check for witness fields using different possible field names
      if (input.witness && Array.isArray(input.witness) && input.witness.length >= 2) {
        witnessData = input.witness;
        witnessInput = i;
        console.log(`Found witness data in input #${i} using 'witness' field`);
        break;
      }
      
      if (input.txinwitness && Array.isArray(input.txinwitness) && input.txinwitness.length >= 2) {
        witnessData = input.txinwitness;
        witnessInput = i;
        console.log(`Found witness data in input #${i} using 'txinwitness' field`);
        break;
      }
      
      // Handle blockchain.info API format that uses flat 'witness' field
      if (input.witness && typeof input.witness === 'string' && input.witness.length > 0) {
        // Try to parse from the string format
        try {
          const parts = input.witness.split(' ');
          if (parts.length >= 2) {
            witnessData = parts;
            witnessInput = i;
            console.log(`Found witness data in input #${i} from string format`);
            break;
          }
        } catch (e) {
          console.log("Could not parse witness string", e);
        }
      }
    }
    
    if (!witnessData) {
      console.error("No witness data found in any transaction input");
      return null;
    }
    
    console.log(`Using witness data from input #${witnessInput}:`, witnessData);
    
    // Parse signature and public key from witness data
    const parsedData = parseWitnessData(witnessData);
    if (!parsedData) {
      console.error("Failed to parse witness data");
      return null;
    }
    
    console.log("Successfully parsed witness data");
    
    // Extract bytes from hex strings
    const sigBytes = getSignatureBytes(parsedData.sigHex);
    const pubKeyBytes = getPublicKeyBytes(parsedData.pubKeyHex);
    
    if (!sigBytes || !pubKeyBytes) {
      console.error("Failed to convert hex to bytes");
      return null;
    }
    
    console.log("Successfully converted signature and pubkey to bytes");
    
    // Extract signature data
    const signature = extractWitnessSignature(sigBytes);
    if (!signature) {
      console.error("Failed to extract witness signature");
      return null;
    }
    
    // Extract public key data
    const publicKey = extractWitnessPublicKey(pubKeyBytes);
    if (!publicKey) {
      console.error("Failed to extract witness public key");
      return null;
    }
    
    console.log("Successfully extracted SegWit cryptographic data:", {
      signature: { r: signature.r.substring(0, 10) + '...', s: signature.s.substring(0, 10) + '...' },
      publicKey: { x: publicKey.x.substring(0, 10) + '...', y: publicKey.y.substring(0, 10) + '...' }
    });
    
    // Return the extracted data
    return {
      signature,
      publicKey,
      rawSignature: parsedData.sigHex,
      rawPublicKey: parsedData.pubKeyHex,
      transactionFormat: 'segwit'
    };
  } catch (error) {
    console.error("Error in SegWit data extraction:", error);
    return null;
  }
};
