
import { parseWitnessData } from './utils/parseWitness';
import { extractWitnessPublicKey } from './utils/publicKeyExtraction';
import { extractWitnessSignature } from './utils/signatureExtraction';
import { PublicKey, CryptographicPoint } from '@/types';
import { hexToBytes } from '../hexUtils';

/**
 * Extract cryptographic data from SegWit transactions
 * @param witnessData Witness data array from transaction
 * @returns Object containing public key and signature data, or null if unsuccessful
 */
export const extractSegWitData = (witnessData: any) => {
  try {
    console.log("Starting SegWit data extraction from witness data");
    
    // Input validation for witness data
    if (!witnessData || !Array.isArray(witnessData) || witnessData.length === 0) {
      console.error("Invalid witness data structure for SegWit extraction");
      return null;
    }
    
    // Log witness data structure to help with debugging
    console.log("Witness data structure:", witnessData.length, "items");
    
    // Handle different witness data formats
    let processedWitnessData = witnessData;
    
    // Handle special case of nested witness arrays in some transaction formats
    if (Array.isArray(witnessData) && witnessData.length === 1 && Array.isArray(witnessData[0])) {
      processedWitnessData = witnessData[0];
      console.log("Using nested witness array:", processedWitnessData.length, "items");
    }
    
    // If witness is a string (sometimes the case in some API responses), try to parse it
    if (processedWitnessData.length === 1 && typeof processedWitnessData[0] === 'string') {
      try {
        // Some APIs may provide witness as JSON string
        const parsed = JSON.parse(processedWitnessData[0]);
        if (Array.isArray(parsed)) {
          processedWitnessData = parsed;
          console.log("Parsed witness data from JSON string");
        }
      } catch (e) {
        // Likely not JSON, continue with original data
        console.log("Witness data is a string but not JSON parseable");
      }
    }
    
    // For P2WPKH, the witness typically has signature and public key
    // For P2WSH, the witness structure is more complex
    if (processedWitnessData.length === 2) {
      console.log("Witness data to parse:", processedWitnessData);
      
      // Parse the witness data - likely P2WPKH (signature, public key)
      const pubKeyHex = typeof processedWitnessData[1] === 'string' ? processedWitnessData[1] : null;
      const sigHex = typeof processedWitnessData[0] === 'string' ? processedWitnessData[0] : null;
      
      if (pubKeyHex && sigHex) {
        console.log("Successfully parsed witness data: sig length =", sigHex.length, "pubKey length =", pubKeyHex.length);
        
        // Try to extract public key - use hexToBytes
        const pubKeyBytes = hexToBytes(pubKeyHex);
        const publicKey = extractWitnessPublicKey(pubKeyBytes);
        
        // Try to extract signature - use hexToBytes
        const sigBytes = hexToBytes(sigHex);
        const signature = extractWitnessSignature(sigBytes);
        
        if (publicKey && signature) {
          console.log("Successfully extracted SegWit cryptographic data:", {
            publicKeyX: publicKey.x.substring(0, 10) + "...",
            publicKeyY: publicKey.y.substring(0, 10) + "..."
          });
          
          return {
            publicKey: publicKey as CryptographicPoint,
            signature: signature
          };
        }
        
        if (publicKey) {
          console.log("Extracted public key but no signature");
          return {
            publicKey: publicKey as CryptographicPoint,
            signature: null
          };
        }
      } else {
        console.log("Invalid signature or public key in witness data");
      }
    } else if (processedWitnessData.length > 2) {
      // This might be P2WSH with more complex script
      // Try to find a public key in the witness items
      for (let i = 0; i < processedWitnessData.length; i++) {
        const item = processedWitnessData[i];
        if (typeof item === 'string') {
          // Look for items that could be public keys (33 or 65 bytes in hex, so 66 or 130 chars)
          if ((item.length === 66 && (item.startsWith('02') || item.startsWith('03'))) || 
              (item.length === 130 && item.startsWith('04'))) {
            
            const pubKeyBytes = hexToBytes(item);
            const publicKey = extractWitnessPublicKey(pubKeyBytes);
            
            if (publicKey) {
              console.log("Found public key in P2WSH witness at position", i);
              
              // Look for potential DER signatures (starts with 30)
              let signature = null;
              for (let j = 0; j < processedWitnessData.length; j++) {
                if (j !== i && typeof processedWitnessData[j] === 'string' && 
                    processedWitnessData[j].startsWith('30')) {
                  
                  const sigBytes = hexToBytes(processedWitnessData[j]);
                  signature = extractWitnessSignature(sigBytes);
                  
                  if (signature) {
                    console.log("Found signature in P2WSH witness at position", j);
                    break;
                  }
                }
              }
              
              return {
                publicKey: publicKey as CryptographicPoint,
                signature
              };
            }
          }
        }
      }
      
      console.log("Could not find public key and signature in P2WSH witness");
    }
    
    // If parseWitnessData can extract the data, use that as a fallback
    const parsedWitness = parseWitnessData(processedWitnessData);
    
    if (parsedWitness) {
      // Try to extract public key
      const publicKey = parsedWitness.pubKeyHex ? 
        extractWitnessPublicKey(hexToBytes(parsedWitness.pubKeyHex)) : 
        null;
      
      // Try to extract signature
      const signature = parsedWitness.sigHex ?
        extractWitnessSignature(hexToBytes(parsedWitness.sigHex)) :
        null;
      
      if (publicKey) {
        console.log("Extracted public key using parsed witness data");
        
        return {
          publicKey: publicKey as CryptographicPoint,
          signature
        };
      }
    }
    
    // If we get here, we couldn't extract the data successfully
    console.error("Failed to extract cryptographic data from witness data");
    return null;
  } catch (error) {
    console.error("Error extracting SegWit data:", error);
    return null;
  }
};
