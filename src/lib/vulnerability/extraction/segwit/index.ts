
/**
 * Segwit transaction data extraction utilities
 */

import { parseWitnessData, getSignatureBytes, getPublicKeyBytes } from './witnessParser';
import { decodeDERSignature } from '@/lib/crypto/signatureUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';

/**
 * Extract cryptographic data from a SegWit transaction
 * @param txData Transaction data from blockchain API
 * @returns Object with public key and signature if found, null otherwise
 */
export const extractSegWitData = (txData: any) => {
  try {
    // Check if the transaction has witness data
    if (!txData || !txData.vin || !Array.isArray(txData.vin) || txData.vin.length === 0) {
      console.log("No inputs in transaction data");
      return null;
    }
    
    let witnessData = null;
    
    // Find the first input with witness data
    for (const vin of txData.vin) {
      if (vin.witness && Array.isArray(vin.witness) && vin.witness.length >= 2) {
        witnessData = vin.witness;
        break;
      }
    }
    
    if (!witnessData) {
      console.log("No witness data found in transaction");
      return null;
    }
    
    // Parse witness data to extract signature and public key
    const parsedWitness = parseWitnessData(witnessData);
    if (!parsedWitness) {
      return null;
    }
    
    // Convert signature from hex to bytes
    const sigBytes = getSignatureBytes(parsedWitness.sigHex);
    if (!sigBytes) {
      return null;
    }
    
    // Convert public key from hex to bytes
    const pubKeyBytes = getPublicKeyBytes(parsedWitness.pubKeyHex);
    if (!pubKeyBytes) {
      return null;
    }
    
    // Process public key - determine if compressed and decompress if needed
    let pubKeyX, pubKeyY;
    
    // If the public key starts with 02 or 03, it's compressed
    if (parsedWitness.pubKeyHex.startsWith('02') || parsedWitness.pubKeyHex.startsWith('03')) {
      const decompressed = decompressPublicKey(parsedWitness.pubKeyHex);
      pubKeyX = decompressed.x;
      pubKeyY = decompressed.y;
    } else if (parsedWitness.pubKeyHex.startsWith('04')) {
      // Uncompressed format: 04 + x + y
      pubKeyX = parsedWitness.pubKeyHex.substring(2, 66);
      pubKeyY = parsedWitness.pubKeyHex.substring(66, 130);
    } else {
      console.error("Unknown public key format");
      return null;
    }
    
    // Decode the signature from DER format
    const { r, s } = decodeDERSignature(parsedWitness.sigHex);
    
    // Return the extracted data
    return {
      publicKey: {
        x: pubKeyX,
        y: pubKeyY,
        isOnCurve: true // We assume it's on curve since it was validated in the transaction
      },
      signature: {
        r,
        s,
        sighash: parsedWitness.sigHex.slice(-2) // Last byte is usually the sighash type
      }
    };
  } catch (error) {
    console.error("Error extracting SegWit data:", error);
    return null;
  }
};
