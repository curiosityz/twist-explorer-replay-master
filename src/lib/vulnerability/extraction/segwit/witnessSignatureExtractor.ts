
/**
 * Utilities for extracting signatures from segwit witness data
 */

import { Signature } from '@/types';
import { bytesToHex } from '../hexUtils';

/**
 * Extract signature from witness using Bitcoin.ECDSA parser
 * @param sigBytes Raw signature bytes
 * @param sigHex Original signature hex string (for alternative parsing)
 * @returns Parsed signature or null if parsing fails
 */
export const extractWitnessSignature = (sigBytes: number[], sigHex: string): Signature | null => {
  try {
    if (!sigBytes || sigBytes.length === 0) {
      console.log("Empty signature bytes");
      return null;
    }
    
    // Use Bitcoin ECDSA parser if available
    if (window.Bitcoin && window.Bitcoin.ECDSA) {
      try {
        const sigData = window.Bitcoin.ECDSA.parseSig(sigHex);
        
        const signature: Signature = {
          r: sigData.r.toString(16).padStart(64, '0'),
          s: sigData.s.toString(16).padStart(64, '0'),
          sighash: ('0' + sigBytes[sigBytes.length - 1].toString(16)).slice(-2)
        };
        
        console.log("Extracted signature using Bitcoin.ECDSA:", 
          "r:", signature.r.substring(0, 10) + "...", 
          "s:", signature.s.substring(0, 10) + "...");
          
        return signature;
      } catch (ecdsaError) {
        console.error("Error using Bitcoin.ECDSA for parsing:", ecdsaError);
        // Fall back to manual parsing
      }
    }
    
    // Manual DER parsing as fallback
    // Usually, the signature starts with 0x30
    if (sigBytes[0] !== 0x30) {
      console.log("Invalid signature format in witness, first byte:", sigBytes[0]);
      return null;
    }
    
    // Parse DER format with better error handling
    let pos = 1; // Start after signature header (0x30)
    const totalLen = sigBytes[pos];
    pos++;
    
    // R value
    if (sigBytes[pos] !== 0x02) {
      console.error("Invalid R value format in witness");
      return null;
    }
    
    pos++;
    const rLen = sigBytes[pos];
    pos++;
    const rValue = sigBytes.slice(pos, pos + rLen);
    pos += rLen;
    
    // S value
    if (sigBytes[pos] !== 0x02) {
      console.error("Invalid S value format in witness");
      return null;
    }
    
    pos++;
    const sLen = sigBytes[pos];
    pos++;
    const sValue = sigBytes.slice(pos, pos + sLen);
    
    // Get sighash byte (last byte)
    const sighashType = sigBytes[sigBytes.length - 1];
    
    // Convert to hex
    const rHex = bytesToHex(rValue).padStart(64, '0');
    const sHex = bytesToHex(sValue).padStart(64, '0');
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    const signature: Signature = {
      r: rHex,
      s: sHex,
      sighash: sighashHex
    };
    
    console.log("Extracted signature from witness using manual parsing:", 
      "r:", signature.r.substring(0, 10) + "...", 
      "s:", signature.s.substring(0, 10) + "...");
      
    return signature;
  } catch (error) {
    console.error("Error extracting witness signature:", error);
    return null;
  }
};
