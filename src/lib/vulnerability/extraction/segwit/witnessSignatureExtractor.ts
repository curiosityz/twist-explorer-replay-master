
/**
 * Extract signatures from SegWit witness data
 */

import { Signature } from '@/types';
import { bytesToHex } from '../hexUtils';

/**
 * Extract signature from SegWit witness stack
 * @param sigBytes Signature bytes from witness stack
 * @returns Structured signature object or null if extraction fails
 */
export const extractWitnessSignature = (sigBytes: Uint8Array | number[]): Signature | null => {
  try {
    // Ensure we have a Uint8Array
    const signatureBytes = sigBytes instanceof Uint8Array ? 
      sigBytes : new Uint8Array(sigBytes);
    
    // Bitcoin ECDSA signatures in DER format end with a sighash flag
    const sighashType = signatureBytes[signatureBytes.length - 1];
    const derSignature = signatureBytes.slice(0, -1);
    
    // Try to use Bitcoin library if available
    if (window.Bitcoin && window.Bitcoin.ECDSA) {
      try {
        return extractSignatureFromBitcoinECDSA(signatureBytes);
      } catch (error) {
        console.error("Error using Bitcoin.ECDSA for signature extraction:", error);
        // Fall through to manual DER parsing
      }
    }
    
    // Manual DER parsing as fallback
    return extractSignatureManually(signatureBytes);
  } catch (error) {
    console.error("Error extracting witness signature:", error);
    return null;
  }
};

/**
 * Extract signature components using Bitcoin ECDSA parser
 * @param sigBytes Raw signature bytes
 * @returns Signature object or null
 */
const extractSignatureFromBitcoinECDSA = (sigBytes: Uint8Array | number[]): Signature | null => {
  try {
    // Ensure we have a Uint8Array
    const signatureBytes = sigBytes instanceof Uint8Array ? 
      sigBytes : new Uint8Array(sigBytes);
    
    // Use bitcoin library for DER signature parsing
    const sigData = window.Bitcoin.ECDSA.parseSigCompact(signatureBytes);
    
    // Extract r, s and sighash
    const r = sigData.r.toString(16).padStart(64, '0');
    const s = sigData.s.toString(16).padStart(64, '0');
    const sighashType = signatureBytes[signatureBytes.length - 1];
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    return {
      r,
      s,
      sighash: sighashHex
    };
  } catch (error) {
    console.error("Error using Bitcoin ECDSA parser:", error);
    return null;
  }
};

/**
 * Extract signature using manual DER parsing
 * @param sigBytes Raw signature bytes
 * @returns Signature object or null
 */
const extractSignatureManually = (sigBytes: Uint8Array | number[]): Signature | null => {
  try {
    // Ensure we have a Uint8Array
    const signatureBytes = sigBytes instanceof Uint8Array ? 
      sigBytes : new Uint8Array(sigBytes);
    
    // Basic DER validation
    if (signatureBytes[0] !== 0x30) {
      console.error("Invalid DER signature format: missing 0x30 header");
      return null;
    }
    
    // Extract r and s values manually from DER structure
    let pos = 1; // Skip 0x30 header
    const totalLen = signatureBytes[pos];
    pos++;
    
    // First integer marker should be 0x02
    if (signatureBytes[pos] !== 0x02) {
      console.error("Invalid DER signature: missing first integer marker");
      return null;
    }
    pos++;
    
    // Length of r value
    const rLen = signatureBytes[pos];
    pos++;
    const rBytes = signatureBytes.slice(pos, pos + rLen);
    pos += rLen;
    
    // Second integer marker should be 0x02
    if (signatureBytes[pos] !== 0x02) {
      console.error("Invalid DER signature: missing second integer marker");
      return null;
    }
    pos++;
    
    // Length of s value
    const sLen = signatureBytes[pos];
    pos++;
    const sBytes = signatureBytes.slice(pos, pos + sLen);
    
    // Get sighash byte (last byte)
    const sighashType = signatureBytes[signatureBytes.length - 1];
    
    // Convert to hex
    const rHex = bytesToHex(rBytes).padStart(64, '0');
    const sHex = bytesToHex(sBytes).padStart(64, '0');
    const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
    
    return {
      r: rHex,
      s: sHex,
      sighash: sighashHex
    };
  } catch (error) {
    console.error("Error in manual signature parsing:", error);
    return null;
  }
};
