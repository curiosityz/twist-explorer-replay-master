
/**
 * Utilities for extracting public keys from segwit witness data
 */

import { CryptographicPoint } from '@/types';
import { bytesToHex } from '../hexUtils';
import { decompressPublicKey } from '@/lib/crypto/publicKeyUtils';

/**
 * Extract public key from witness public key bytes
 * @param pubKeyBytes Raw public key bytes
 * @param pubKeyHex Original public key hex string
 * @returns Extracted public key point or null if extraction fails
 */
export const extractWitnessPublicKey = (pubKeyBytes: number[], pubKeyHex: string): CryptographicPoint | null => {
  try {
    if (!pubKeyBytes || pubKeyBytes.length === 0) {
      console.log("Empty public key bytes in witness");
      return null;
    }
    
    // Check if it's a valid public key format
    if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
      // Uncompressed key (04 + x + y)
      const xBytes = pubKeyBytes.slice(1, 33);
      const yBytes = pubKeyBytes.slice(33, 65);
      
      const xHex = bytesToHex(xBytes);
      const yHex = bytesToHex(yBytes);
      
      const publicKey: CryptographicPoint = {
        x: xHex,
        y: yHex,
        isOnCurve: true
      };
      
      console.log("Extracted uncompressed public key from witness:", 
        "x:", publicKey.x.substring(0, 10) + "...", 
        "y:", publicKey.y.substring(0, 10) + "...");
        
      return publicKey;
    }
    else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
      // Use secp256k1 library directly to decompress the key if available
      if (window.secp256k1) {
        try {
          // Fixed: removed the second parameter that was causing TypeScript errors
          const decompressed = window.secp256k1.publicKeyConvert(pubKeyBytes);
          
          // Extract x and y coordinates (format: 04 | x | y)
          const xBytes = decompressed.slice(1, 33);
          const yBytes = decompressed.slice(33, 65);
          
          const xHex = bytesToHex(xBytes);
          const yHex = bytesToHex(yBytes);
          
          const publicKey: CryptographicPoint = {
            x: xHex,
            y: yHex,
            isOnCurve: true
          };
          
          console.log("Decompressed witness public key using secp256k1:", 
            "x:", publicKey.x.substring(0, 10) + "...", 
            "y:", publicKey.y.substring(0, 10) + "...");
            
          return publicKey;
        } catch (secp256k1Error) {
          console.error("Error using secp256k1 to decompress key:", secp256k1Error);
          
          // Fall back to our utility if secp256k1 direct call fails
          const decomp = decompressPublicKey(pubKeyHex);
          
          return {
            x: decomp.x,
            y: decomp.y,
            isOnCurve: decomp.isOnCurve
          };
        }
      } else {
        // Fall back to our utility function if secp256k1 isn't available
        const decomp = decompressPublicKey(pubKeyHex);
        
        const publicKey: CryptographicPoint = {
          x: decomp.x,
          y: decomp.y,
          isOnCurve: decomp.isOnCurve
        };
        
        console.log("Decompressed witness public key using utility:", 
          "x:", publicKey.x.substring(0, 10) + "...", 
          "y:", publicKey.y.substring(0, 10) + "...");
          
        return publicKey;
      }
    } else {
      console.log("Invalid public key format in witness. First byte:", pubKeyBytes[0], "Length:", pubKeyBytes.length);
      return null;
    }
  } catch (error) {
    console.error("Error extracting witness public key:", error);
    return null;
  }
};
