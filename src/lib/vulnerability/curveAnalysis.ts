
import { CryptographicPoint, AnalysisResult, VulnerabilityType } from '@/types';
import { supabase, Tables } from '@/integrations/supabase/client';
import { 
  isPointOnCurve, 
  isPointOnTwistCurve,
  hexToBigInt,
  twistParams,
  factorize,
  solveDiscreteLog
} from '../cryptoUtils';
import { calculatePrivateKeyModulo } from './keyRecovery';
import { prepareAnalysisResult } from './analysisUtils';

/**
 * Check if a point is on the twist curve and analyze it for vulnerabilities
 * @param publicKey Public key point
 * @returns Analysis result object or null
 */
export const analyzePublicKeyForVulnerabilities = async (
  txid: string,
  publicKey: CryptographicPoint
): Promise<AnalysisResult | null> => {
  try {
    console.log("Analyzing public key for vulnerabilities:", publicKey);
    
    // Convert hex strings to BigInt for analysis
    const x = hexToBigInt(publicKey.x);
    const y = hexToBigInt(publicKey.y);
    
    // Check if the public key is valid using Bitcoin libraries if available
    let isValidKey = true;
    if (window.secp256k1) {
      try {
        // Create compressed format for validation
        const prefix = y % 2n === 0n ? '02' : '03';
        const compressedHex = prefix + publicKey.x.padStart(64, '0');
        
        // Convert hex to byte array
        const compressedBytes = new Uint8Array(
          compressedHex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16))
        );
        
        // Use secp256k1 library to validate
        isValidKey = window.secp256k1.publicKeyVerify(compressedBytes);
        
        if (!isValidKey) {
          console.log("Public key failed secp256k1 verification - invalid key");
        }
      } catch (validationError) {
        console.error("Error validating with secp256k1:", validationError);
        // Continue with analysis even if validation fails
        isValidKey = false;
      }
    }
    
    // Check if the point is on the main curve
    const onMainCurve = isPointOnCurve(x, y);
    if (onMainCurve) {
      console.log("Point is on the main curve - no twist vulnerability");
      // Store analysis result for on-curve point
      const insertData = {
        txid,
        public_key: publicKey as any,
        vulnerability_type: VulnerabilityType.NONE,
        message: "Public key is on the main curve - no twist vulnerability detected",
        status: "completed"
      };
      
      const { data, error } = await supabase
        .from(Tables.vulnerability_analyses)
        .insert(insertData)
        .select()
        .single();
        
      if (error) {
        console.error("Error storing analysis result:", error);
        return null;
      }
      
      return prepareAnalysisResult(data);
    }
    
    // Check if point is on the twist curve
    const onTwistCurve = isPointOnTwistCurve(x, y);
    if (onTwistCurve) {
      console.log("Point is on the twist curve - VULNERABLE!");
      
      // Calculate the twist curve order
      const twistOrder = twistParams.n.toString();
      
      // Calculate prime factors of the twist order using our factorize function
      console.log("Starting factorization of twist curve order...");
      const primeFactors = calculatePrimeFactors(twistParams.n);
      console.log("Prime factorization complete:", primeFactors);
      
      // Calculate the private key modulo each prime factor
      // This is where we try to solve the discrete logarithm for each prime factor
      console.log("Calculating private key modulos for each prime factor...");
      const privateKeyModulo = calculatePrivateKeyModulo(
        primeFactors,
        [x, y]
      );
      
      console.log("Private key modulo calculation complete:", privateKeyModulo);
      
      // Insert the analysis with the calculated data
      const insertData = {
        txid,
        public_key: publicKey as any,
        vulnerability_type: VulnerabilityType.TWISTED_CURVE,
        twist_order: twistOrder,
        prime_factors: primeFactors,
        private_key_modulo: privateKeyModulo,
        message: "Public key is on the twist curve - potentially vulnerable to private key recovery",
        status: "completed",
        recovered_private_key: null // Initialize with null
      };
      
      const { data, error } = await supabase
        .from(Tables.vulnerability_analyses)
        .insert(insertData)
        .select()
        .single();
        
      if (error) {
        console.error("Error storing analysis result:", error);
        return null;
      }
      
      return prepareAnalysisResult(data);
    }
    
    // Point is not on either curve
    console.log("Point is not on the main curve or twist curve - invalid key");
    const insertData = {
      txid,
      public_key: publicKey as any,
      vulnerability_type: VulnerabilityType.INVALID,
      message: "Public key is not on the main curve or twist curve - invalid point",
      status: "completed"
    };
      
    const { data, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .insert(insertData)
      .select()
      .single();
      
    if (error) {
      console.error("Error storing analysis result:", error);
      return null;
    }
    
    return prepareAnalysisResult(data);
  } catch (error) {
    console.error("Error analyzing public key:", error);
    return null;
  }
};

/**
 * Calculate prime factors for a big integer using advanced factorization algorithms
 * @param n Number to factorize
 * @returns Array of prime factors as strings
 */
const calculatePrimeFactors = (n: bigint): string[] => {
  console.log(`Calculating prime factors for: ${n} using advanced factorization`);
  
  try {
    // Use our factorize function that leverages multiple algorithms
    const factors = factorize(n);
    
    // Attempt to verify some of the factors using secp256k1 if available
    if (window.secp256k1 && factors.length > 0) {
      console.log("Verifying factors using secp256k1 library...");
      
      // Verification is expensive, so just check a few largest factors
      const largestFactors = factors
        .sort((a, b) => (BigInt(b) > BigInt(a) ? 1 : -1))
        .slice(0, 5);
        
      largestFactors.forEach(factor => {
        const factorBigInt = BigInt(factor);
        let product = 1n;
        
        for (let i = 0n; i < factorBigInt; i++) {
          product = (product * factorBigInt) % n;
          // If we get back to 1 before reaching factorBigInt, it's confirmed
          if (product === 1n) {
            console.log(`Factor ${factor} verified by checking order`);
            break;
          }
        }
      });
    }
    
    // Log and return unique factors
    console.log(`Final verified factors: ${factors.join(', ')}`);
    return factors;
  } catch (error) {
    console.error("Error during factorization:", error);
    
    // Fallback to simpler factorization if the advanced methods fail
    const factors: bigint[] = [];
    
    // Trial division with small primes as a fallback
    const smallPrimes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 
                        43n, 47n, 53n, 59n, 61n, 67n, 71n, 73n, 79n, 83n, 89n, 97n];
    
    let num = n;
    
    for (const prime of smallPrimes) {
      while (num % prime === 0n) {
        factors.push(prime);
        num = num / prime;
      }
      
      if (num === 1n) break;
    }
    
    if (num > 1n) {
      factors.push(num); // Add any remaining factor
    }
    
    // Return unique factors
    const uniqueFactors = [...new Set(factors)];
    console.log(`Fallback factorization resulted in: ${uniqueFactors.join(', ')}`);
    
    return uniqueFactors.map(f => f.toString());
  }
};
