
import { CryptographicPoint, AnalysisResult, VulnerabilityType } from '@/types';
import { supabase, Tables } from '@/integrations/supabase/client';
import { 
  isPointOnCurve, 
  isPointOnTwistCurve,
  hexToBigInt,
  twistParams,
  factorize
} from '../cryptoUtils';
import { calculatePrivateKeyModulo } from './keyRecovery';
import { prepareAnalysisResult } from './analysisUtils';

/**
 * Check if a point is on the twist curve and analyze it for vulnerabilities
 * @param publicKey Public key point
 * @returns Analysis result object or null
 */
export const analyzePublicKeyForVulnerabilities = async (
  txid: string,
  publicKey: CryptographicPoint
): Promise<AnalysisResult | null> => {
  try {
    console.log("Analyzing public key for vulnerabilities:", publicKey);
    
    // Convert hex strings to BigInt for analysis
    const x = hexToBigInt(publicKey.x);
    const y = hexToBigInt(publicKey.y);
    
    // Check if the point is on the main curve
    if (isPointOnCurve(x, y)) {
      console.log("Point is on the main curve - no twist vulnerability");
      // Store analysis result for on-curve point
      const insertData = {
        txid,
        public_key: publicKey as any,
        vulnerability_type: VulnerabilityType.NONE,
        message: "Public key is on the main curve - no twist vulnerability detected",
        status: "completed"
      };
      
      const { data, error } = await supabase
        .from(Tables.vulnerability_analyses)
        .insert(insertData)
        .select()
        .single();
        
      if (error) {
        console.error("Error storing analysis result:", error);
        return null;
      }
      
      return prepareAnalysisResult(data);
    }
    
    // Check if point is on the twist curve
    if (isPointOnTwistCurve(x, y)) {
      console.log("Point is on the twist curve - VULNERABLE!");
      
      // Calculate the twist curve order
      const twistOrder = twistParams.n.toString();
      
      // Calculate prime factors of the twist order
      const primeFactors = calculatePrimeFactors(twistParams.n);
      
      // Calculate the private key modulo each prime factor
      const privateKeyModulo = calculatePrivateKeyModulo(
        primeFactors,
        [x, y]
      );
      
      // Insert the analysis with the calculated data
      const insertData = {
        txid,
        public_key: publicKey as any,
        vulnerability_type: VulnerabilityType.TWISTED_CURVE,
        twist_order: twistOrder,
        prime_factors: primeFactors,
        private_key_modulo: privateKeyModulo,
        message: "Public key is on the twist curve - potentially vulnerable to private key recovery",
        status: "completed",
        recovered_private_key: null // Initialize with null
      };
      
      const { data, error } = await supabase
        .from(Tables.vulnerability_analyses)
        .insert(insertData)
        .select()
        .single();
        
      if (error) {
        console.error("Error storing analysis result:", error);
        return null;
      }
      
      return prepareAnalysisResult(data);
    }
    
    // Point is not on either curve
    console.log("Point is not on the main curve or twist curve - invalid key");
    const insertData = {
      txid,
      public_key: publicKey as any,
      vulnerability_type: VulnerabilityType.INVALID,
      message: "Public key is not on the main curve or twist curve - invalid point",
      status: "completed"
    };
      
    const { data, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .insert(insertData)
      .select()
      .single();
      
    if (error) {
      console.error("Error storing analysis result:", error);
      return null;
    }
    
    return prepareAnalysisResult(data);
  } catch (error) {
    console.error("Error analyzing public key:", error);
    return null;
  }
};

/**
 * Calculate prime factors for a big integer using advanced factorization algorithms
 * @param n Number to factorize
 * @returns Array of prime factors as strings
 */
const calculatePrimeFactors = (n: bigint): string[] => {
  console.log(`Calculating prime factors for: ${n} using advanced factorization`);
  
  try {
    // Use our new factorize function that leverages multiple algorithms
    const factors = factorize(n);
    
    // Log and return unique factors
    console.log(`Final unique factors: ${factors.join(', ')}`);
    return factors;
  } catch (error) {
    console.error("Error during factorization:", error);
    
    // Fallback to simpler factorization if the advanced methods fail
    const factors: bigint[] = [];
    
    // Trial division with small primes as a fallback
    const smallPrimes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 
                        43n, 47n, 53n, 59n, 61n, 67n, 71n, 73n, 79n, 83n, 89n, 97n];
    
    let num = n;
    
    for (const prime of smallPrimes) {
      while (num % prime === 0n) {
        factors.push(prime);
        num = num / prime;
      }
      
      if (num === 1n) break;
    }
    
    if (num > 1n) {
      factors.push(num); // Add any remaining factor
    }
    
    // Return unique factors
    const uniqueFactors = [...new Set(factors)];
    console.log(`Fallback factorization resulted in: ${uniqueFactors.join(', ')}`);
    
    return uniqueFactors.map(f => f.toString());
  }
};
