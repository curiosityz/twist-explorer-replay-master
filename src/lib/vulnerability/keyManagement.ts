
import { CryptographicPoint } from '@/types';
import { normalizeKeyFragment } from '../database';
import { supabase, Tables } from '@/integrations/supabase/client';
import { verifyPrivateKey } from '../cryptoUtils';

/**
 * Checks if a recovered private key is valid for a given public key
 * This uses the cryptoUtils verification function but adds error handling
 * @param privateKey Recovered private key
 * @param publicKey Public key point
 * @returns Boolean indicating if key is valid and verified
 */
export const verifyRecoveredKey = (
  privateKey: string | null,
  publicKey: CryptographicPoint | undefined
): boolean => {
  if (!privateKey || !publicKey) {
    console.log("Missing key data for verification");
    return false;
  }
  
  try {
    return verifyPrivateKey(privateKey, publicKey.x, publicKey.y);
  } catch (error) {
    console.error('Error verifying recovered key:', error);
    return false;
  }
};

/**
 * Fetches key fragments for a public key from the database
 * @param publicKeyHex Public key in hex format
 * @returns Key fragment data or null if not found
 */
export const fetchKeyFragmentsForPublicKey = async (publicKeyHex: string) => {
  try {
    const { data, error } = await supabase
      .from(Tables.private_key_fragments)
      .select('*')
      .eq('public_key_hex', publicKeyHex)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching key fragments:', error);
      return null;
    }
    
    return normalizeKeyFragment(data);
  } catch (error) {
    console.error('Error in fetchKeyFragmentsForPublicKey:', error);
    return null;
  }
};

/**
 * Save key fragments to the database
 * @param publicKeyHex Public key in hex format
 * @param fragments Key fragments (modulo values)
 * @param combinedKey Recovered private key (if available)
 */
export const saveKeyFragments = async (
  publicKeyHex: string, 
  fragments: Record<string, string>,
  combinedKey: string | null = null
): Promise<boolean> => {
  try {
    // Check if entry already exists first to avoid conflicts
    const { data: existingEntry } = await supabase
      .from(Tables.private_key_fragments)
      .select('id')
      .eq('public_key_hex', publicKeyHex)
      .maybeSingle();
    
    const fragmentData = {
      public_key_hex: publicKeyHex,
      modulo_values: fragments,
      combined_fragments: combinedKey,
      completed: !!combinedKey
    };
    
    let result;
    
    if (existingEntry) {
      // Update existing record
      result = await supabase
        .from(Tables.private_key_fragments)
        .update(fragmentData)
        .eq('id', existingEntry.id);
    } else {
      // Insert new record
      result = await supabase
        .from(Tables.private_key_fragments)
        .insert(fragmentData);
    }
    
    if (result.error) {
      console.error("Error saving key fragments:", result.error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error("Error in saveKeyFragments:", error);
    return false;
  }
};
