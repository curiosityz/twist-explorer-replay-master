
import { CryptographicPoint, Signature } from '@/types';

/**
 * Extract signature and public key from transaction data
 * @param txData Transaction data from RPC
 * @returns Extracted cryptographic data or null
 */
export const extractCryptographicData = (txData: any) => {
  try {
    if (!txData || !txData.vin || txData.vin.length === 0) {
      console.log("No inputs found in transaction data");
      return null;
    }

    console.log("Transaction inputs:", txData.vin.length);
    
    // Try to extract signature and public key from each input
    for (const input of txData.vin) {
      let sigHex: string | undefined;
      let pubKeyHex: string | undefined;
      
      // Case 1: P2PKH input with scriptSig (legacy)
      if (input.scriptSig && input.scriptSig.hex) {
        console.log("Processing P2PKH input with scriptSig");
        const scriptSigHex = input.scriptSig.hex;
        
        // Find DER signature - it usually starts with 0x30
        const sigStart = scriptSigHex.indexOf('30');
        
        if (sigStart >= 0 && sigStart + 2 < scriptSigHex.length) {
          // Parse DER signature length
          const sigLengthHex = scriptSigHex.substring(sigStart + 2, sigStart + 4);
          const sigLength = parseInt(sigLengthHex, 16);
          
          // Extract signature including the 30 prefix, length byte, and data
          // Add additional bytes for DER format and SIGHASH
          const fullSigLength = (sigLength + 3) * 2; // convert bytes to hex chars
          sigHex = scriptSigHex.substring(sigStart, sigStart + fullSigLength);
          
          // Public key usually follows the signature after a push operation byte
          const pubKeyStart = sigStart + fullSigLength + 2; // +2 for push byte
          
          if (pubKeyStart < scriptSigHex.length - 2) {
            // Read public key size
            const pubKeyLengthHex = scriptSigHex.substring(pubKeyStart, pubKeyStart + 2);
            const pubKeyLength = parseInt(pubKeyLengthHex, 16) * 2; // convert bytes to hex chars
            
            // Extract public key
            pubKeyHex = scriptSigHex.substring(pubKeyStart + 2, pubKeyStart + 2 + pubKeyLength);
            
            console.log("Extracted from scriptSig - signature:", sigHex.substring(0, 16) + "...", 
                       "public key:", pubKeyHex.substring(0, 16) + "...");
          }
        }
      } 
      // Case 2: P2WPKH or P2WSH with witness data (segwit)
      else if (input.txinwitness && input.txinwitness.length >= 2) {
        console.log("Processing P2WPKH/P2WSH input with witness data");
        sigHex = input.txinwitness[0]; // First witness item is signature
        pubKeyHex = input.txinwitness[1]; // Second witness item is public key
        
        console.log("Extracted from witness - signature:", sigHex.substring(0, 16) + "...", 
                    "public key:", pubKeyHex.substring(0, 16) + "...");
      }
      
      // If we successfully extracted both signature and public key
      if (sigHex && pubKeyHex) {
        // Parse the public key
        let pubKeyX: string;
        let pubKeyY: string;
        
        // Process based on key format
        if (pubKeyHex.length >= 130 && pubKeyHex.startsWith('04')) {
          // Uncompressed key (04 + x + y)
          pubKeyX = pubKeyHex.substring(2, 66);
          pubKeyY = pubKeyHex.substring(66, 130);
        }
        else if (pubKeyHex.length >= 66 && (pubKeyHex.startsWith('02') || pubKeyHex.startsWith('03'))) {
          // Compressed key - we need to decompress to get y coordinate
          // For the MVP, we'll only handle uncompressed keys
          // In a real implementation, we'd decompress the key here
          console.log("Compressed public key detected - skipping for now");
          continue;
        }
        else {
          console.log("Unknown public key format, length:", pubKeyHex.length);
          continue;
        }
        
        // Parse the DER signature to extract r and s values
        let rValue: string;
        let sValue: string;
        
        try {
          // Very simple DER parsing - in a real implementation, we'd use a proper DER parser
          // Format is typically: [30][len][02][r_len][r][02][s_len][s][sighash_type]
          const rLength = parseInt(sigHex.substring(6, 8), 16) * 2;
          rValue = sigHex.substring(8, 8 + rLength);
          
          // s starts after r plus the type marker (02) and length byte
          const sStart = 8 + rLength + 2;
          const sLength = parseInt(sigHex.substring(sStart, sStart + 2), 16) * 2;
          sValue = sigHex.substring(sStart + 2, sStart + 2 + sLength);
          
          // Get the sighash type which should be the last byte
          const sighashType = sigHex.substring(sigHex.length - 2);
          
          // Return the extracted data
          return {
            signature: {
              r: rValue,
              s: sValue,
              sighash: sighashType
            } as Signature,
            publicKey: {
              x: pubKeyX,
              y: pubKeyY,
              isOnCurve: false // We'll check this in the analysis
            } as CryptographicPoint
          };
        } 
        catch (err) {
          console.error("Error parsing DER signature:", err);
          continue;
        }
      }
    }
    
    console.log("Failed to extract cryptographic data from any inputs");
    return null;
  } catch (error) {
    console.error("Error extracting cryptographic data:", error);
    return null;
  }
};
