
import { CryptographicPoint, Signature } from '@/types';

/**
 * Extract signature and public key from transaction data
 * @param txData Transaction data from RPC
 * @returns Extracted cryptographic data or null
 */
export const extractCryptographicData = (txData: any) => {
  try {
    if (!txData) {
      console.log("No transaction data provided");
      return null;
    }
    
    if (!txData.vin || !Array.isArray(txData.vin) || txData.vin.length === 0) {
      console.log("No inputs found in transaction data");
      return null;
    }

    console.log(`Transaction inputs: ${txData.vin.length}`);
    console.log("Transaction data structure:", JSON.stringify(txData).substring(0, 500) + "...");
    
    // Try to extract signature and public key from each input
    for (const input of txData.vin) {
      let sigHex: string | undefined;
      let pubKeyHex: string | undefined;
      
      // Case 1: P2PKH input with scriptSig (legacy)
      if (input.scriptSig && input.scriptSig.hex) {
        console.log("Processing P2PKH input with scriptSig");
        const scriptSigHex = input.scriptSig.hex;
        
        // Find DER signature - it usually starts with 0x30
        const sigStart = scriptSigHex.indexOf('30');
        
        if (sigStart >= 0 && sigStart + 2 < scriptSigHex.length) {
          try {
            // Parse DER signature length
            const sigLengthHex = scriptSigHex.substring(sigStart + 2, sigStart + 4);
            const sigLength = parseInt(sigLengthHex, 16);
            
            // Extract signature including the 30 prefix, length byte, and data
            // Add additional bytes for DER format and SIGHASH
            const fullSigLength = (sigLength + 3) * 2; // convert bytes to hex chars
            if (sigStart + fullSigLength <= scriptSigHex.length) {
              sigHex = scriptSigHex.substring(sigStart, sigStart + fullSigLength);
              
              // Public key usually follows the signature after a push operation byte
              const pubKeyStart = sigStart + fullSigLength + 2; // +2 for push byte
              
              if (pubKeyStart < scriptSigHex.length - 2) {
                // Read public key size
                const pubKeyLengthHex = scriptSigHex.substring(pubKeyStart, pubKeyStart + 2);
                const pubKeyLength = parseInt(pubKeyLengthHex, 16) * 2; // convert bytes to hex chars
                
                // Extract public key
                if (pubKeyStart + 2 + pubKeyLength <= scriptSigHex.length) {
                  pubKeyHex = scriptSigHex.substring(pubKeyStart + 2, pubKeyStart + 2 + pubKeyLength);
                  
                  console.log("Extracted from scriptSig - signature:", sigHex.substring(0, 16) + "...", 
                            "public key:", pubKeyHex.substring(0, 16) + "...");
                }
              }
            }
          } catch (err) {
            console.error("Error parsing scriptSig data:", err);
          }
        }
      } 
      // Case 2: P2WPKH or P2WSH with witness data (segwit)
      else if (input.txinwitness && Array.isArray(input.txinwitness) && input.txinwitness.length >= 2) {
        console.log("Processing P2WPKH/P2WSH input with witness data");
        sigHex = input.txinwitness[0]; // First witness item is signature
        pubKeyHex = input.txinwitness[1]; // Second witness item is public key
        
        console.log("Extracted from witness - signature:", sigHex?.substring(0, 16) + "...", 
                  "public key:", pubKeyHex?.substring(0, 16) + "...");
      }
      // Case 3: Non-standard script format (try to find any potential keys)
      else {
        console.log("Non-standard input format, looking for public keys");
        
        // Try to find any string that looks like a public key in any available field
        const inputStr = JSON.stringify(input);
        
        // Look for uncompressed public keys (start with 04, followed by 128 hex chars)
        const uncompressedKeyRegex = /04[a-fA-F0-9]{128}/g;
        const uncompressedMatches = inputStr.match(uncompressedKeyRegex);
        
        if (uncompressedMatches && uncompressedMatches.length > 0) {
          pubKeyHex = uncompressedMatches[0];
          console.log("Found potential uncompressed public key:", pubKeyHex.substring(0, 16) + "...");
        } else {
          // Look for compressed public keys (start with 02 or 03, followed by 64 hex chars)
          const compressedKeyRegex = /0[23][a-fA-F0-9]{64}/g;
          const compressedMatches = inputStr.match(compressedKeyRegex);
          
          if (compressedMatches && compressedMatches.length > 0) {
            pubKeyHex = compressedMatches[0];
            console.log("Found potential compressed public key:", pubKeyHex);
            // For compressed keys, we'll need to handle it differently later
          } else {
            console.log("No public key pattern found in this input");
          }
        }
      }
      
      // If we successfully extracted both signature and public key
      if (sigHex && pubKeyHex) {
        // Parse the public key
        let pubKeyX: string;
        let pubKeyY: string;
        
        // Process based on key format
        if (pubKeyHex.length >= 130 && pubKeyHex.startsWith('04')) {
          // Uncompressed key (04 + x + y)
          pubKeyX = pubKeyHex.substring(2, 66);
          pubKeyY = pubKeyHex.substring(66, 130);
          
          console.log("Successfully parsed uncompressed public key");
        }
        else if (pubKeyHex.length >= 66 && (pubKeyHex.startsWith('02') || pubKeyHex.startsWith('03'))) {
          console.log("Compressed public key detected - skipping for now");
          continue;
        }
        else {
          console.log("Unknown public key format, length:", pubKeyHex.length);
          continue;
        }
        
        // Parse the DER signature to extract r and s values
        let rValue: string;
        let sValue: string;
        
        try {
          // Very simple DER parsing - in a real implementation, we'd use a proper DER parser
          // Format is typically: [30][len][02][r_len][r][02][s_len][s][sighash_type]
          const rLength = parseInt(sigHex.substring(6, 8), 16) * 2;
          
          if (isNaN(rLength) || rLength <= 0 || rLength > sigHex.length) {
            console.error("Invalid r-value length in DER signature");
            continue;
          }
          
          rValue = sigHex.substring(8, 8 + rLength);
          
          // s starts after r plus the type marker (02) and length byte
          const sStart = 8 + rLength + 2;
          
          if (sStart >= sigHex.length) {
            console.error("Invalid s-value position in DER signature");
            continue;
          }
          
          const sLength = parseInt(sigHex.substring(sStart, sStart + 2), 16) * 2;
          
          if (isNaN(sLength) || sLength <= 0 || sStart + 2 + sLength > sigHex.length) {
            console.error("Invalid s-value length in DER signature");
            continue;
          }
          
          sValue = sigHex.substring(sStart + 2, sStart + 2 + sLength);
          
          // Get the sighash type which should be the last byte
          const sighashType = sigHex.substring(sigHex.length - 2);
          
          console.log("Successfully parsed DER signature");
          
          // Return the extracted data
          return {
            signature: {
              r: rValue,
              s: sValue,
              sighash: sighashType
            } as Signature,
            publicKey: {
              x: pubKeyX,
              y: pubKeyY,
              isOnCurve: false // We'll check this in the analysis
            } as CryptographicPoint
          };
        } 
        catch (err) {
          console.error("Error parsing DER signature:", err);
          continue;
        }
      } else {
        console.log("Could not extract both signature and public key from this input");
      }
    }
    
    console.log("Failed to extract cryptographic data from any inputs");
    throw new Error("Could not extract cryptographic data from transaction");
  } catch (error) {
    console.error("Error extracting cryptographic data:", error);
    throw new Error("Could not extract cryptographic data from transaction");
  }
};
