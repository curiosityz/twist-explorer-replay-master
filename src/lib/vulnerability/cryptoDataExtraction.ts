
import { CryptographicPoint, Signature } from '@/types';

// Define a global bitcoinjs type for TypeScript
declare global {
  interface Window {
    Bitcoin: any;
    bs58: any;
    bip39: any;
    bech32: any;
    secp256k1: any;
    bitcoinMessage: any;
    bitcoinOps: any;
    bitcoinAddressValidation: any;
  }
}

/**
 * Extract signature and public key from transaction data
 * @param txData Transaction data from RPC
 * @returns Extracted cryptographic data or null
 */
export const extractCryptographicData = (txData: any) => {
  try {
    if (!txData) {
      console.log("No transaction data provided");
      return null;
    }
    
    if (!txData.vin || !Array.isArray(txData.vin) || txData.vin.length === 0) {
      console.log("No inputs found in transaction data");
      return null;
    }

    console.log(`Transaction inputs: ${txData.vin.length}`);
    console.log("Transaction data structure:", JSON.stringify(txData).substring(0, 500) + "...");
    
    // Try to extract signature and public key from each input
    for (const input of txData.vin) {
      let signature: Signature | undefined;
      let publicKey: CryptographicPoint | undefined;
      
      try {
        // Case 1: P2PKH input with scriptSig (legacy)
        if (input.scriptSig && input.scriptSig.hex) {
          console.log("Processing P2PKH input with scriptSig");
          
          try {
            // Use bitcoinjs to parse the script
            const scriptSig = window.Bitcoin.Script.fromHex(input.scriptSig.hex);
            
            if (scriptSig && scriptSig.chunks && scriptSig.chunks.length >= 2) {
              // P2PKH typically has 2 chunks: signature and public key
              const sigChunk = scriptSig.chunks[0];
              const pubKeyChunk = scriptSig.chunks[1];
              
              if (sigChunk && pubKeyChunk) {
                console.log("Found potential scriptSig chunks");
                
                // Extract signature (DER format with sighash byte at the end)
                const sigBytes = sigChunk;
                if (sigBytes && sigBytes.length > 0) {
                  // Usually, the signature starts with 0x30
                  if (sigBytes[0] === 0x30) {
                    try {
                      // Parse DER format
                      let pos = 2; // Skip 0x30 and length byte
                      
                      // R value
                      if (sigBytes[pos] === 0x02) { // Integer type
                        pos++;
                        const rLen = sigBytes[pos];
                        pos++;
                        const rValue = sigBytes.slice(pos, pos + rLen);
                        pos += rLen;
                        
                        // S value
                        if (sigBytes[pos] === 0x02) { // Integer type
                          pos++;
                          const sLen = sigBytes[pos];
                          pos++;
                          const sValue = sigBytes.slice(pos, pos + sLen);
                          pos += sLen;
                          
                          // Get sighash byte (last byte)
                          const sighashType = sigBytes[sigBytes.length - 1];
                          
                          // Convert to hex - fixed: removed function call argument
                          const rHex = Array.from(rValue).map(b => ('0' + b.toString(16)).slice(-2)).join('');
                          const sHex = Array.from(sValue).map(b => ('0' + b.toString(16)).slice(-2)).join('');
                          const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
                          
                          signature = {
                            r: rHex,
                            s: sHex,
                            sighash: sighashHex
                          };
                          
                          console.log("Extracted signature from DER:", 
                            "r:", signature.r.substring(0, 10) + "...", 
                            "s:", signature.s.substring(0, 10) + "...");
                        }
                      }
                    } catch (err) {
                      console.error("Error parsing DER signature:", err);
                    }
                  }
                }
                
                // Extract public key
                const pubKeyBytes = pubKeyChunk;
                if (pubKeyBytes && pubKeyBytes.length > 0) {
                  // Check if it's a valid public key format
                  if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
                    // Uncompressed key (04 + x + y)
                    const xBytes = pubKeyBytes.slice(1, 33);
                    const yBytes = pubKeyBytes.slice(33, 65);
                    
                    // Fixed: removed function call argument
                    const xHex = Array.from(xBytes).map(b => ('0' + b.toString(16)).slice(-2)).join('');
                    const yHex = Array.from(yBytes).map(b => ('0' + b.toString(16)).slice(-2)).join('');
                    
                    publicKey = {
                      x: xHex,
                      y: yHex,
                      isOnCurve: true // We'll check this in the analysis
                    };
                    
                    console.log("Extracted uncompressed public key:", 
                      "x:", publicKey.x.substring(0, 10) + "...", 
                      "y:", publicKey.y.substring(0, 10) + "...");
                  }
                  else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
                    // Compressed key (02/03 + x)
                    // For compressed keys, we need to compute the y coordinate
                    const compressed = pubKeyBytes[0] === 0x03;
                    const xBytes = pubKeyBytes.slice(1, 33);
                    const xHex = Array.from(xBytes).map(b => ('0' + b.toString(16)).slice(-2)).join('');
                    
                    try {
                      // Try to decompress the key using Bitcoin.js
                      const ecKey = new window.Bitcoin.ECKey();
                      ecKey.setPub(pubKeyBytes);
                      const point = ecKey.getPubPoint();
                      
                      if (point && point.getX && point.getY) {
                        const x = point.getX().toString(16).padStart(64, '0');
                        const y = point.getY().toString(16).padStart(64, '0');
                        
                        publicKey = {
                          x: x,
                          y: y,
                          isOnCurve: true
                        };
                        
                        console.log("Decompressed compressed public key:", 
                          "x:", publicKey.x.substring(0, 10) + "...", 
                          "y:", publicKey.y.substring(0, 10) + "...");
                      }
                    } catch (err) {
                      console.error("Error decompressing public key:", err);
                    }
                  }
                }
              }
            }
          } catch (err) {
            console.error("Error parsing scriptSig using bitcoinjs:", err);
          }
        } 
        // Case 2: P2WPKH or P2WSH with witness data (segwit)
        else if (input.txinwitness && Array.isArray(input.txinwitness) && input.txinwitness.length >= 2) {
          console.log("Processing P2WPKH/P2WSH input with witness data");
          const sigHex = input.txinwitness[0]; 
          const pubKeyHex = input.txinwitness[1];
          
          if (sigHex && pubKeyHex) {
            try {
              // Parse signature from witness
              const sigBytes = window.Bitcoin.Util.hexToBytes(sigHex);
              
              if (sigBytes && sigBytes.length > 0 && sigBytes[0] === 0x30) {
                try {
                  // Parse DER format
                  let pos = 2; // Skip 0x30 and length byte
                  
                  // R value
                  if (sigBytes[pos] === 0x02) { // Integer type
                    pos++;
                    const rLen = sigBytes[pos];
                    pos++;
                    const rValue = sigBytes.slice(pos, pos + rLen);
                    pos += rLen;
                    
                    // S value
                    if (sigBytes[pos] === 0x02) { // Integer type
                      pos++;
                      const sLen = sigBytes[pos];
                      pos++;
                      const sValue = sigBytes.slice(pos, pos + sLen);
                      pos += sLen;
                      
                      // Get sighash byte (last byte)
                      const sighashType = sigBytes[sigBytes.length - 1];
                      
                      // Convert to hex - Fixed: removed function call argument
                      const rHex = Array.from(rValue).map(b => ('0' + b.toString(16)).slice(-2)).join('');
                      const sHex = Array.from(sValue).map(b => ('0' + b.toString(16)).slice(-2)).join('');
                      const sighashHex = ('0' + sighashType.toString(16)).slice(-2);
                      
                      signature = {
                        r: rHex,
                        s: sHex,
                        sighash: sighashHex
                      };
                      
                      console.log("Extracted signature from witness:", 
                        "r:", signature.r.substring(0, 10) + "...", 
                        "s:", signature.s.substring(0, 10) + "...");
                    }
                  }
                } catch (err) {
                  console.error("Error parsing witness DER signature:", err);
                }
              }
              
              // Parse public key from witness
              const pubKeyBytes = window.Bitcoin.Util.hexToBytes(pubKeyHex);
              
              if (pubKeyBytes && pubKeyBytes.length > 0) {
                // Check if it's a valid public key format
                if (pubKeyBytes[0] === 0x04 && pubKeyBytes.length === 65) {
                  // Uncompressed key (04 + x + y)
                  const xBytes = pubKeyBytes.slice(1, 33);
                  const yBytes = pubKeyBytes.slice(33, 65);
                  
                  // Fixed: removed function call argument
                  const xHex = Array.from(xBytes).map(b => ('0' + b.toString(16)).slice(-2)).join('');
                  const yHex = Array.from(yBytes).map(b => ('0' + b.toString(16)).slice(-2)).join('');
                  
                  publicKey = {
                    x: xHex,
                    y: yHex,
                    isOnCurve: true
                  };
                  
                  console.log("Extracted uncompressed public key from witness:", 
                    "x:", publicKey.x.substring(0, 10) + "...", 
                    "y:", publicKey.y.substring(0, 10) + "...");
                }
                else if ((pubKeyBytes[0] === 0x02 || pubKeyBytes[0] === 0x03) && pubKeyBytes.length === 33) {
                  // Compressed key (02/03 + x)
                  try {
                    // Try to decompress the key using Bitcoin.js
                    const ecKey = new window.Bitcoin.ECKey();
                    ecKey.setPub(pubKeyBytes);
                    const point = ecKey.getPubPoint();
                    
                    if (point && point.getX && point.getY) {
                      const x = point.getX().toString(16).padStart(64, '0');
                      const y = point.getY().toString(16).padStart(64, '0');
                      
                      publicKey = {
                        x: x,
                        y: y,
                        isOnCurve: true
                      };
                      
                      console.log("Decompressed compressed public key from witness:", 
                        "x:", publicKey.x.substring(0, 10) + "...", 
                        "y:", publicKey.y.substring(0, 10) + "...");
                    }
                  } catch (err) {
                    console.error("Error decompressing witness public key:", err);
                  }
                }
              }
            } catch (err) {
              console.error("Error parsing witness data:", err);
            }
          }
        }
        
        // If both signature and public key were extracted successfully
        if (signature && publicKey) {
          console.log("Successfully extracted both signature and public key");
          return { signature, publicKey };
        }
      } catch (inputError) {
        console.error("Error processing input:", inputError);
        // Continue to next input
      }
    }
    
    console.log("Failed to extract cryptographic data from any inputs");
    throw new Error("Could not extract cryptographic data from transaction");
  } catch (error) {
    console.error("Error extracting cryptographic data:", error);
    throw new Error("Could not extract cryptographic data from transaction");
  }
};
