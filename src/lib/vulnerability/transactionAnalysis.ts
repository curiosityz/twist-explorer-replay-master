
import { AnalysisResult, VulnerabilityType } from '@/types';
import { normalizeVulnerabilityAnalysis } from '../database';
import { supabase, Tables } from '@/integrations/supabase/client';
import { toast } from 'sonner';
import { chainstackService } from '@/services/chainstackService';
import { extractCryptographicData } from './cryptoDataExtraction';
import { analyzePublicKeyForVulnerabilities } from './curveAnalysis';
import { verifyPrivateKey } from '../cryptoUtils';
import { saveKeyFragments as storeKeyFragments } from '../keyStorage';
import { prepareAnalysisResult } from './analysisUtils';
import { combinePrivateKeyFragments } from '../cryptoUtils';

/**
 * Analyzes transaction for potential vulnerabilities
 * @param txid Transaction ID to analyze
 * @returns Analysis result or null if analysis failed
 */
export const analyzeTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    // Check if an analysis already exists
    const { data: existingAnalysis, error: checkError } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (checkError) {
      console.error("Error checking existing analysis:", checkError);
    } else if (existingAnalysis && existingAnalysis.vulnerability_type !== VulnerabilityType.UNKNOWN) {
      // Parse existing analysis result
      const preparedResult = prepareAnalysisResult(existingAnalysis);
      if (preparedResult) {
        toast.info("This transaction has already been analyzed", {
          description: "The key fragments have already been extracted from this transaction."
        });
        
        // Even if it exists, attempt to process the key fragments and recover the private key
        if (preparedResult.privateKeyModulo && 
            Object.keys(preparedResult.privateKeyModulo).length >= 6) {
          console.log("Found existing analysis with key fragments, attempting to recover private key...");
          const recoveredKey = combinePrivateKeyFragments(preparedResult.privateKeyModulo);
          
          if (recoveredKey) {
            console.log("Successfully recovered private key from existing fragments:", recoveredKey);
            const publicKeyHex = preparedResult.publicKey.x + preparedResult.publicKey.y;
            
            // Store in both local storage and database
            storeKeyFragments(txid, preparedResult.privateKeyModulo, recoveredKey);
            await saveKeyFragments(publicKeyHex, preparedResult.privateKeyModulo, recoveredKey);
            
            // Update the analysis with the recovered key
            preparedResult.recoveredPrivateKey = recoveredKey;
            
            // Also update the database record
            const updateResult = await supabase
              .from(Tables.vulnerability_analyses)
              .update({
                recovered_private_key: recoveredKey
              })
              .eq('id', existingAnalysis.id);
              
            if (updateResult.error) {
              console.error("Error updating analysis with recovered key:", updateResult.error);
            }
          } else {
            console.error("Failed to recover private key from existing fragments");
          }
        }
        
        return preparedResult;
      }
    }
    
    // Perform real-time analysis on the blockchain data
    toast.loading("Analyzing transaction for vulnerabilities...", {
      id: "analyzing-transaction"
    });
    
    try {
      // Fetch the transaction data from the blockchain via RPC
      console.log("Fetching transaction data for:", txid);
      const txData = await chainstackService.getTransaction(txid);
      
      if (!txData) {
        toast.dismiss("analyzing-transaction");
        toast.error("Failed to fetch transaction data", { 
          description: "Could not retrieve the transaction from the blockchain" 
        });
        return null;
      }
      
      console.log("Successfully retrieved transaction data");
      
      // Extract the public key and signature from the transaction
      const cryptoData = extractCryptographicData(txData);
      
      if (!cryptoData) {
        toast.dismiss("analyzing-transaction");
        toast.error("Failed to extract cryptographic data", { 
          description: "Could not find a valid signature and public key in this transaction" 
        });
        
        // Store a record of the failed analysis
        await supabase
          .from(Tables.vulnerability_analyses)
          .insert({
            txid,
            public_key: { x: "0", y: "0", isOnCurve: false } as any,
            vulnerability_type: VulnerabilityType.UNKNOWN,
            message: "Could not extract cryptographic data from transaction",
            status: "failed"
          });
          
        return null;
      }
      
      console.log("Successfully extracted cryptographic data:", {
        publicKeyX: cryptoData.publicKey.x.substring(0, 16) + "...",
        publicKeyY: cryptoData.publicKey.y.substring(0, 16) + "..."
      });
      
      // Analyze the public key for vulnerabilities using full implementation
      const result = await analyzePublicKeyForVulnerabilities(txid, cryptoData.publicKey);
      
      toast.dismiss("analyzing-transaction");
      
      if (result) {
        if (result.vulnerabilityType === VulnerabilityType.TWISTED_CURVE) {
          toast.success("Vulnerability detected!", {
            description: "This transaction contains a public key on the twist curve"
          });
          
          // If we have enough key fragments, try to recover the private key immediately
          if (result.privateKeyModulo && Object.keys(result.privateKeyModulo).length >= 6) {
            console.log("Attempting to recover private key from fragments...");
            const recoveredKey = combinePrivateKeyFragments(result.privateKeyModulo);
            
            if (recoveredKey) {
              console.log("Successfully recovered private key:", recoveredKey);
              
              // Verify the key against the public key
              const isValid = verifyPrivateKey(
                recoveredKey,
                cryptoData.publicKey.x,
                cryptoData.publicKey.y
              );
              
              if (isValid) {
                console.log("Verified recovered private key is valid!");
                
                // Update the analysis with the recovered key
                const updateResult = await supabase
                  .from(Tables.vulnerability_analyses)
                  .update({
                    recovered_private_key: recoveredKey
                  })
                  .eq('txid', txid);
                  
                if (updateResult.error) {
                  console.error("Error updating analysis with recovered key:", updateResult.error);
                } else {
                  result.recoveredPrivateKey = recoveredKey;
                  toast.success("Private key successfully recovered!", {
                    description: "The private key for this public key has been recovered."
                  });
                }
              } else {
                console.error("Recovered key failed verification");
                toast.error("Key recovery verification failed", {
                  description: "The recovered private key failed verification."
                });
              }
            }
          }
        } else {
          toast.info("Analysis complete", {
            description: `Result: ${result.vulnerabilityType}`
          });
        }
      }
      
      return result;
    } catch (error) {
      console.error("Error in blockchain analysis:", error);
      toast.dismiss("analyzing-transaction");
      toast.error("Failed to analyze blockchain data", {
        description: error instanceof Error ? error.message : "Unknown error"
      });
      
      return null;
    }
  } catch (error) {
    console.error('Error analyzing transaction:', error);
    toast.dismiss("analyzing-transaction");
    toast.error("Failed to analyze transaction");
    return null;
  }
};

/**
 * Fetches analysis result for a transaction from the database
 * @param txid Transaction ID to fetch analysis for
 * @returns Analysis result or null if not found
 */
export const fetchAnalysisForTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    const { data: analysisData, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching analysis:', error);
      return null;
    }
    
    return prepareAnalysisResult(analysisData);
  } catch (error) {
    console.error('Error in fetchAnalysisForTransaction:', error);
    return null;
  }
};
