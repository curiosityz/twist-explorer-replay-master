/**
 * Core transaction vulnerability analysis functionality
 */

import { AnalysisResult, VulnerabilityType } from '@/types';
import { extractCryptographicData } from '../extraction';
import { analyzePublicKeyForVulnerabilities } from '../curveAnalysis';
import { toast } from 'sonner';
import { verifyPrivateKey } from '../../cryptoUtils';
import { combinePrivateKeyFragments } from '../../cryptoUtils';
import { storeAnalysisInDatabase, updateAnalysisWithRecoveredKey } from './databaseOperations';
import { saveKeyFragments } from '../keyManagement';
import { saveKeyFragments as storeKeyFragments } from '../../keyStorage';

/**
 * Performs real-time analysis on a transaction to detect vulnerabilities
 * @param txid Transaction ID to analyze
 * @param txData Raw transaction data from blockchain
 * @returns Analysis result or null if analysis failed
 */
export const performAnalysis = async (
  txid: string,
  txData: any
): Promise<AnalysisResult | null> => {
  try {
    // Extract the public key and signature from the transaction
    const cryptoData = extractCryptographicData(txData);
    
    if (!cryptoData) {
      toast.dismiss("analyzing-transaction");
      toast.error("Failed to extract cryptographic data", { 
        description: "Could not find a valid signature and public key in this transaction" 
      });
      
      // Store a record of the failed analysis
      await storeAnalysisInDatabase({
        txid,
        public_key: { x: "0", y: "0", isOnCurve: false } as any,
        vulnerability_type: VulnerabilityType.UNKNOWN,
        message: "Could not extract cryptographic data from transaction",
        status: "failed"
      });
        
      throw new Error("Could not extract cryptographic data from transaction");
    }
    
    console.log("Successfully extracted cryptographic data:", {
      publicKeyX: cryptoData.publicKey.x.substring(0, 16) + "...",
      publicKeyY: cryptoData.publicKey.y.substring(0, 16) + "..."
    });
    
    // Analyze the public key for vulnerabilities using full implementation
    const result = await analyzePublicKeyForVulnerabilities(txid, cryptoData.publicKey);
    
    toast.dismiss("analyzing-transaction");
    
    if (result) {
      if (result.vulnerabilityType === VulnerabilityType.TWISTED_CURVE) {
        toast.success("Vulnerability detected!", {
          description: "This transaction contains a public key on the twist curve"
        });
        
        // If we have enough key fragments, try to recover the private key immediately
        if (result.privateKeyModulo && Object.keys(result.privateKeyModulo).length >= 6) {
          console.log("Attempting to recover private key from fragments...");
          const recoveredKey = combinePrivateKeyFragments(result.privateKeyModulo);
          
          if (recoveredKey) {
            console.log("Successfully recovered private key:", recoveredKey);
            
            // Verify the key against the public key
            const isValid = verifyPrivateKey(
              recoveredKey,
              cryptoData.publicKey.x,
              cryptoData.publicKey.y
            );
            
            if (isValid) {
              console.log("Verified recovered private key is valid!");
              
              // Update the analysis with the recovered key
              const updateResult = await updateAnalysisWithRecoveredKey(txid, recoveredKey);
                
              if (!updateResult) {
                console.error("Error updating analysis with recovered key");
              } else {
                result.recoveredPrivateKey = recoveredKey;
                
                // Store in both local storage and database
                const publicKeyHex = cryptoData.publicKey.x + cryptoData.publicKey.y;
                storeKeyFragments(txid, result.privateKeyModulo, recoveredKey);
                await saveKeyFragments(publicKeyHex, result.privateKeyModulo, recoveredKey);
                
                toast.success("Private key successfully recovered!", {
                  description: "The private key for this public key has been recovered."
                });
              }
            } else {
              console.error("Recovered key failed verification");
              toast.error("Key recovery verification failed", {
                description: "The recovered private key failed verification."
              });
            }
          }
        }
      } else {
        toast.info("Analysis complete", {
          description: `Result: ${result.vulnerabilityType}`
        });
      }
    }
    
    return result;
  } catch (error) {
    console.error("Error in blockchain analysis:", error);
    throw error;
  }
};
