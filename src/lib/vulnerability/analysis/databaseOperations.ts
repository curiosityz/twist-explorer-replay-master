
/**
 * Database operations for transaction analysis
 */

import { supabase, Tables } from '@/integrations/supabase/client';
import { AnalysisResult } from '@/types';
import { prepareAnalysisResult } from '../analysisUtils';
import { normalizeVulnerabilityAnalysis } from '@/lib/database';

/**
 * Fetches analysis result for a transaction from the database
 * @param txid Transaction ID to fetch analysis for
 * @returns Analysis result or null if not found
 */
export const fetchAnalysisForTransaction = async (txid: string): Promise<AnalysisResult | null> => {
  try {
    const { data: analysisData, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error('Error fetching analysis:', error);
      return null;
    }
    
    return prepareAnalysisResult(analysisData);
  } catch (error) {
    console.error('Error in fetchAnalysisForTransaction:', error);
    return null;
  }
};

/**
 * Stores a failed analysis record in the database
 * @param analysisData Analysis data to store
 * @returns Boolean indicating success
 */
export const storeAnalysisInDatabase = async (analysisData: any): Promise<boolean> => {
  try {
    const { error } = await supabase
      .from(Tables.vulnerability_analyses)
      .insert(analysisData);
      
    if (error) {
      console.error("Error storing analysis:", error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error in storeAnalysisInDatabase:', error);
    return false;
  }
};

/**
 * Updates an analysis record with a recovered private key
 * @param txid Transaction ID to update
 * @param recoveredKey Recovered private key
 * @returns Boolean indicating success
 */
export const updateAnalysisWithRecoveredKey = async (
  txid: string, 
  recoveredKey: string
): Promise<boolean> => {
  try {
    const { error } = await supabase
      .from(Tables.vulnerability_analyses)
      .update({
        recovered_private_key: recoveredKey
      })
      .eq('txid', txid);
      
    if (error) {
      console.error("Error updating analysis with recovered key:", error);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error in updateAnalysisWithRecoveredKey:', error);
    return false;
  }
};

/**
 * Checks if a transaction has already been analyzed
 * @param txid Transaction ID to check
 * @returns Analysis data or null if not found
 */
export const checkExistingAnalysis = async (txid: string) => {
  try {
    const { data: existingAnalysis, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('txid', txid)
      .limit(1)
      .maybeSingle();
    
    if (error) {
      console.error("Error checking existing analysis:", error);
      return null;
    }
    
    return existingAnalysis;
  } catch (error) {
    console.error("Error in checkExistingAnalysis:", error);
    return null;
  }
};

/**
 * Loads an existing analysis result by ID
 * @param analysisId Analysis ID to load
 * @returns Analysis result or null if not found
 */
export const loadAnalysisById = async (analysisId: string): Promise<AnalysisResult | null> => {
  try {
    const { data: analysisData, error } = await supabase
      .from(Tables.vulnerability_analyses)
      .select('*')
      .eq('id', analysisId)
      .maybeSingle();
      
    if (error) {
      console.error("Error loading existing analysis:", error);
      return null;
    }
    
    if (!analysisData) {
      return null;
    }
    
    // Normalize the data
    const normalizedData = normalizeVulnerabilityAnalysis(analysisData);
    
    if (!normalizedData) {
      return null;
    }
    
    return prepareAnalysisResult(normalizedData);
  } catch (error) {
    console.error("Error in loadAnalysisById:", error);
    return null;
  }
};
